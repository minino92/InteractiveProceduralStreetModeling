/*
This file contains routines that fullfil the sketch based design
*/

#include "stdafx.h"

#include "VFDataStructure.h"

#include "BmpProcess.h"

#include "SketchDesign.h"

#include "tensoranalysis.h"

#include "tensordesign.h"

#include "shareinterfacevars.h"
extern SharedInterfaceVars sharedvars;

extern TenRegularElem *ten_regularelems;
extern int nten_regelems;
extern Degenerate_Design *ten_designelems;
extern int ntenelems;

int gen_regElem_sketches=0;  /*total number of regular elements generated by the sketches*/

SketchList *brushes=NULL;

int NDesignRegions=0;

int cur_chosen_region=0;

unsigned char cur_max_reg_index = 0;  /*   current maximum region index   */


/*we will use line segment to store the sketch line 11/22/2007*/
TrajectoryList *sketchlines=NULL;
TrajectoryList *t_sketchlines=NULL;

#include "EvenlyStreamlines.h"
extern EvenStreamlinePlace *major, *minor;
extern EvenStreamlinePlace *major_level1;
extern EvenStreamlinePlace *minor_level1;

/*we use the following graph to obtain the approximate 
region segmentatoin 11/22/2007*/
TensorLineIntersectionInfoList **sketchlineintersectinfo=NULL;
StreetNet *sketchnet=NULL;

/*The line segment list for the four boundaries*/
TrajectoryList *domainboundaries=NULL;
TensorLineIntersectionInfoList **domainboundintersectinfo=NULL;

int prev_nsketchlines;

bool highwayexisted=false;

void sample_along_tensorline_from_to(Trajectory *traj, int start_lineseg, double startp[2],
									 int end_lineseg, double endp[2], 
									 int edgeid, StreetNet *net);
int nRoads_majDir;
extern bool majorroadsexisted;

/*******        Testing code (variables)        *******/

unsigned char *test_diff_regions=NULL;
int test_region_width=512;
int test_region_height=512;

unsigned char *coloredregion=NULL;

extern QuadMesh *quadmesh;

void init_brushlist()
{
	if(brushes==NULL)
		brushes=new SketchList();
	int i;
	for(i=0; i<brushes->curMaxNum; i++)
	{
		//if(brushes->brushlist[i]!=NULL)
			brushes->brushlist[i].nelems=0;
	}
	brushes->nbrushes=0;

	init_brush_trajs();
	init_sketchlineinfo_incells();
}


/*
Keep track of the mouse movement to obtain the brush path
*/
void add_to_current_brushPts(double x, double y)
{
	int i;

	ctr_point *new_brushpt=(ctr_point*)malloc(sizeof(ctr_point));
	new_brushpt->x=x;
	new_brushpt->y=y;
	//new_brushpt->cellid=;

	brushes->brushlist[brushes->nbrushes].append(new_brushpt);

}


/*
     Initialize the trajectory list and intersection list for the
	 domain boundaries.
     Here we assume a rectangular region (four regular boundaries) is used.
*/
void init_domain_boundaries()
{
	//TrajectoryList *domainboundaries=NULL;
	//TensorLineIntersectionInfoList *domainboundintersectinfo=NULL;

	int i;
	/*   initialize the boundary line segment list   */
    if(domainboundaries==NULL)
		domainboundaries=new TrajectoryList(4);

	for(i=0;i<domainboundaries->curMaxNumTrajs;i++)
		domainboundaries->trajs[i]=new Trajectory(i, quadmesh->XDIM+1);

	/*   we save the line segments of the four boundaries respectively   */

	Trajectory *traj;
	traj=domainboundaries->trajs[0];
	double x, y;

	/*    boundary 1:  bottom left --> bottom right  */
	y=quadmesh->ystart/*+1.e-8*/;
	for(i=0;i<quadmesh->XDIM-1;i++)
	{
		x=quadmesh->xstart+i*quadmesh->xinterval;
		traj->linesegs[i].gstart[0]=x;
		traj->linesegs[i].gstart[1]=y;
		traj->linesegs[i].Triangle_ID=i;
		x=quadmesh->xstart+(i+1)*quadmesh->xinterval;
		traj->linesegs[i].gend[0]=x;
		traj->linesegs[i].gend[1]=y;
		traj->linesegs[i].length=quadmesh->xinterval;
	}
	traj->nlinesegs=quadmesh->XDIM-1;

	/*    boundary 2:  bottom right --> upper right  */
	traj=domainboundaries->trajs[1];
	x=quadmesh->xend/*-1.e-8*/;
	int CurCell=quadmesh->XDIM-2;
	for(i=0;i<quadmesh->YDIM-1;i++)
	{
		y=quadmesh->ystart+i*quadmesh->yinterval;
		traj->linesegs[i].gstart[0]=x;
		traj->linesegs[i].gstart[1]=y;
		traj->linesegs[i].Triangle_ID=CurCell;
		y=quadmesh->ystart+(i+1)*quadmesh->yinterval;
		traj->linesegs[i].gend[0]=x;
		traj->linesegs[i].gend[1]=y;
		traj->linesegs[i].length=quadmesh->yinterval;
		CurCell+=(quadmesh->XDIM-1);
	}
	traj->nlinesegs=quadmesh->XDIM-1;
	
	/*    boundary 3:  upper left --> upper right  */
	traj=domainboundaries->trajs[2];
	y=quadmesh->yend/*-1.e-8*/;
	for(i=0;i<quadmesh->XDIM-1;i++)
	{
		x=quadmesh->xstart+i*quadmesh->xinterval;
		traj->linesegs[i].gstart[0]=x;
		traj->linesegs[i].gstart[1]=y;
		traj->linesegs[i].Triangle_ID=i+quadmesh->nfaces-quadmesh->XDIM+1;
		x=quadmesh->xstart+(i+1)*quadmesh->xinterval;
		traj->linesegs[i].gend[0]=x;
		traj->linesegs[i].gend[1]=y;
		traj->linesegs[i].length=quadmesh->xinterval;
	}
	traj->nlinesegs=quadmesh->XDIM-1;

	/*    boundary 4:  bottom left --> upper left  */
	traj=domainboundaries->trajs[3];
	x=quadmesh->xstart/*+1.e-8*/;
	CurCell=0;
	for(i=0;i<quadmesh->YDIM-1;i++)
	{
		y=quadmesh->ystart+i*quadmesh->yinterval;
		traj->linesegs[i].gstart[0]=x;
		traj->linesegs[i].gstart[1]=y;
		traj->linesegs[i].Triangle_ID=CurCell;
		y=quadmesh->ystart+(i+1)*quadmesh->yinterval;
		traj->linesegs[i].gend[0]=x;
		traj->linesegs[i].gend[1]=y;
		traj->linesegs[i].length=quadmesh->yinterval;
		CurCell+=(quadmesh->XDIM-1);
	}
	traj->nlinesegs=quadmesh->XDIM-1;

	domainboundaries->ntrajs=4;

	/*   initialize the intersection info list    */
	if(domainboundintersectinfo==NULL)
	{
		domainboundintersectinfo=new TensorLineIntersectionInfoList *[4];

		for(i=0; i<4; i++)
			domainboundintersectinfo[i] = new TensorLineIntersectionInfoList();
		/*  put the four vertices of the rectangular domain into the
			boundary intersection info list
			possible bug here, since one point has been treated as 
			two intersections here 1/2/2008
		*/
		IntersectionInfo *newinfo_bottomleft
			=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
		newinfo_bottomleft->intersect_id=0;
		newinfo_bottomleft->lineseg_id=0;
		
		IntersectionInfo *newinfo_bottomright
			=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
		newinfo_bottomright->intersect_id=1;
		newinfo_bottomright->lineseg_id=quadmesh->XDIM-2;
		
		IntersectionInfo *newinfo_bottomright2
			=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
		newinfo_bottomright2->intersect_id=1;
		newinfo_bottomright2->lineseg_id=0;

		IntersectionInfo *newinfo_upperleft
			=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
		newinfo_upperleft->intersect_id=2;
		newinfo_upperleft->lineseg_id=quadmesh->XDIM-2;

		IntersectionInfo *newinfo_upperleft2
			=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
		newinfo_upperleft2->intersect_id=2;
		newinfo_upperleft2->lineseg_id=0;

		IntersectionInfo *newinfo_upperright
			=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
		newinfo_upperright->intersect_id=3;
		newinfo_upperright->lineseg_id=quadmesh->XDIM-2;

		/*  boundary 1: bottom left --> bottom right  */
		domainboundintersectinfo[0]=new TensorLineIntersectionInfoList(5);
		domainboundintersectinfo[0]->sorted_add(newinfo_bottomleft);
		domainboundintersectinfo[0]->sorted_add(newinfo_bottomright);
		
		/*  boundary 2: bottom right --> upper right  */
		domainboundintersectinfo[1]=new TensorLineIntersectionInfoList(5);
		domainboundintersectinfo[1]->sorted_add(newinfo_bottomright2);
		domainboundintersectinfo[1]->sorted_add(newinfo_upperright);

		/*  boundary 3: upper left --> upper right  */
		domainboundintersectinfo[2]=new TensorLineIntersectionInfoList(5);
		domainboundintersectinfo[2]->sorted_add(newinfo_upperleft2);
		domainboundintersectinfo[2]->sorted_add(newinfo_upperright);

		/*  boundary 4: bottom left --> upper left  */
		domainboundintersectinfo[3]=new TensorLineIntersectionInfoList(5);
		domainboundintersectinfo[3]->sorted_add(newinfo_bottomleft);
		domainboundintersectinfo[3]->sorted_add(newinfo_upperleft);
	}
}


void release_domain_boundaries()
{
	int i, j;
	if(domainboundintersectinfo!=NULL)
	{
		//for(i=0;i<4;i++)
		//{
		//	if(domainboundintersectinfo[i]!=NULL){
		//		delete domainboundintersectinfo[i];
		//		domainboundintersectinfo[i]=NULL;
		//	}
		//}

		delete [] domainboundintersectinfo;
		domainboundintersectinfo=NULL;
	}

	if(domainboundaries!=NULL)
	{
		//for(i=0;i<4;i++)
		//{
		//	if(domainboundaries->trajs[i]!=NULL)
		//	{
		//		delete domainboundaries->trajs[i];
		//		domainboundaries->trajs[i]=NULL;
		//	}
		//}
		delete domainboundaries;
		domainboundaries=NULL;
	}
}

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/*              Test codes here
*/



/*Test the different region tensor field design
*/

void load_the_test_img(char *filename)
{
	test_diff_regions = BmpToTexture(filename, &test_region_width, &test_region_height);

	mark_vertices(quadmesh->xstart, quadmesh->xend, quadmesh->ystart, quadmesh->yend,
		test_diff_regions);
}



/*mark the vertices into two regions in the testing case:
region 0: white
region 1: black
*/
void mark_vertices(double xstart, double xend, double ystart, double yend,
				   unsigned char *map)
{
	double xrang = xend-xstart;
	double yrang = yend-ystart;
	double dx=xrang/(test_region_width-1);
	double dy=yrang/(test_region_height-1);
	int i;

	/*mark the verties*/
	for(i=0; i<quadmesh->nverts; i++)
	{
		int c=(quadmesh->quad_verts[i]->x-xstart)/dx;
		int r=(quadmesh->quad_verts[i]->y-ystart)/dy;

		int id=(r*(test_region_width)+c);

		/*we consider a map with only black/white colors*/
		if(map[3*id]<125)
			quadmesh->quad_verts[i]->which_region = 1;
		else
			quadmesh->quad_verts[i]->which_region = 0;
	}

	/*mark the cells*/
	for(i=0;i<quadmesh->nfaces;i++)
		quadmesh->quadcells[i]->which_region=get_region_id_for_cell(i);
}


/*
*/
int get_region_id_for_cell(int cellid)
{
	QuadCell *face=quadmesh->quadcells[cellid];
	QuadVertex *v;
	int temp_region=0;

	int i;
		
	v=quadmesh->quad_verts[face->verts[0]];
	temp_region=v->which_region;
	for(i=1;i<face->nverts;i++)
	{
		v=quadmesh->quad_verts[face->verts[i]];

		if(v->which_region==temp_region)
			return temp_region;
		temp_region=v->which_region;
	}
}

/*
*/
unsigned char get_region_id(double x, double y)
{
	int i=(x-quadmesh->xstart)/quadmesh->xinterval;
	int j=(y-quadmesh->ystart)/quadmesh->yinterval;

	if(i>=quadmesh->XDIM-1) i=quadmesh->XDIM-2;
	if(j>=quadmesh->YDIM-1) j=quadmesh->YDIM-2;

	int cellid=j*(quadmesh->XDIM-1)+i;
	return quadmesh->quadcells[cellid]->which_region;
}



/*********************************************************************/
/*          The following routines convert the brushes into trajectories
*/

extern icVector2 tenline_dir_global;
extern int get_cellID_givencoords(double,double);
extern bool is_in_cell(int, double, double);
extern void get_next_cell(int &face_id, double pre[2], double cur[2], 
					 int &PassVertornot, int type);

void init_brush_trajs()
{
	if(sketchlines==NULL)
		sketchlines=new TrajectoryList(50);
	int i;
	for(i=0;i<sketchlines->curMaxNumTrajs;i++)
	{
		if(sketchlines->trajs[i]!=NULL)
			sketchlines->trajs[i]->nlinesegs=0;
	}
	sketchlines->ntrajs=0;
}

void convert_brushes_to_trajectories()
{
}



void get_linesegs_twopts_on_asketchline(ctr_point *p1, int cell1, 
										ctr_point *p2, int cell2,
										int &nlines, Trajectory *traj)
{
	double pre_p[2]={p1->x, p1->y};
	double cur_p[2]={p2->x, p2->y};
	int i;
	int cur_cell = cell1;
	QuadCell *face;
	icVector2 linedir;
	linedir.set((cur_p[0]-pre_p[0]),(cur_p[1]-pre_p[1]));
	normalize(linedir);
	tenline_dir_global = linedir;

	cur_cell=cell1;

	icVector2 t_major[4];
	int count = 1;

	/*  could be a bug here (infinite loop) */
	while(cur_cell != cell2 && count<100)
	{
		if(!is_in_cell(cur_cell, cur_p[0], cur_p[1]))
		{
			/*find the next cell the curve will enter*/

			//double temp_p[2]={cur_p[0], cur_p[1]};
			
				/*construct a new line segment here*/
				if(traj->nlinesegs>=traj->curMaxNumLinesegs)
				{
					traj->extend_line_segments(50);
				}
				traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
				traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
				traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];

			/*we first store the major vectors of the vertices
			of current cell*/
			face = quadmesh->quadcells[cur_cell];
			for(i=0; i<4; i++)
				t_major[i]=quadmesh->quad_verts[face->verts[i]]->major;

			/*replace them with the line segment direction*/
			for(i=0; i<4; i++)
				quadmesh->quad_verts[face->verts[i]]->major=tenline_dir_global/*linedir*/;

			int passvertornot = 0;
			double t_p[2]={pre_p[0], pre_p[1]};
			get_next_cell_2(cur_cell, pre_p, cur_p, passvertornot, 0);

			if(cur_cell<0 || cur_cell>=quadmesh->nfaces)
				return;


			if(passvertornot > 0)
			{
				/*construct a new line segment here*/
				traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
				traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
				linedir.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
					traj->linesegs[traj->nlinesegs].gstart[0];
				linedir.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
					traj->linesegs[traj->nlinesegs].gstart[1];
				traj->linesegs[traj->nlinesegs].length=length(linedir);
				traj->nlinesegs++;
				
				if(traj->nlinesegs>=traj->curMaxNumLinesegs)
				{
					traj->extend_line_segments(50);
				}
				traj->linesegs[traj->nlinesegs].gstart[0]=cur_p[0];
				traj->linesegs[traj->nlinesegs].gstart[1]=cur_p[1];
				traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			}
			else
			{
				pre_p[0] = cur_p[0];
				pre_p[1] = cur_p[1];
			}

			/*construct a new line segment here*/
			traj->linesegs[traj->nlinesegs].gend[0]=pre_p[0];
			traj->linesegs[traj->nlinesegs].gend[1]=pre_p[1];
			linedir.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
				traj->linesegs[traj->nlinesegs].gstart[0];
			linedir.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
				traj->linesegs[traj->nlinesegs].gstart[1];
			traj->linesegs[traj->nlinesegs].length=length(linedir);
			traj->nlinesegs++;

			cur_p[0] = p2->x;
			cur_p[1] = p2->y;

			//linedir.set((cur_p[0]-pre_p[0]),(cur_p[1]-pre_p[1]));
			//normalize(linedir);

			/*store back the original vectors*/
			for(i=0; i<4; i++)
				quadmesh->quad_verts[face->verts[i]]->major=t_major[i];
		}

		count++;
	}

	/*add one more line segment*/
	if(traj->nlinesegs>=traj->curMaxNumLinesegs)
	{
		traj->extend_line_segments(5);
	}
	traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
	traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
	traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
	traj->linesegs[traj->nlinesegs].gend[0]=p2->x;
	traj->linesegs[traj->nlinesegs].gend[1]=p2->y;
	linedir.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
		traj->linesegs[traj->nlinesegs].gstart[0];
	linedir.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
		traj->linesegs[traj->nlinesegs].gstart[1];
	traj->linesegs[traj->nlinesegs].length=length(linedir);
	traj->nlinesegs++;
	
}


/*  Convert one brush into a trajectory
*/
void convert_one_brush_to_atraj(int id)
{
	Brush *abrush=&brushes->brushlist[id];
	Trajectory *traj=new Trajectory(id, abrush->nelems);

	int i;
	int lineid=0;
	int cell1, cell2;
	icVector2 line_dir;
	for(i=0;i<abrush->nelems-1;i++)
	{
		cell1=get_cellID_givencoords(abrush->brushpts[i]->x, abrush->brushpts[i]->y);
		cell2=get_cellID_givencoords(abrush->brushpts[i+1]->x, abrush->brushpts[i+1]->y);
		
		if(traj->nlinesegs>=traj->curMaxNumLinesegs)
		{
			traj->extend_line_segments(100);
		}

		if(cell1==cell2)
		{
			traj->linesegs[lineid].gstart[0]=abrush->brushpts[i]->x;
			traj->linesegs[lineid].gstart[1]=abrush->brushpts[i]->y;
			traj->linesegs[lineid].gend[0]=abrush->brushpts[i+1]->x;
			traj->linesegs[lineid].gend[1]=abrush->brushpts[i+1]->y;
			traj->linesegs[lineid].Triangle_ID=cell1;
			line_dir.entry[0]=abrush->brushpts[i+1]->x-abrush->brushpts[i]->x;
			line_dir.entry[1]=abrush->brushpts[i+1]->y-abrush->brushpts[i]->y;
			traj->linesegs[lineid].length=length(line_dir);
			lineid++;
			traj->nlinesegs=lineid;
		}
		else
		{
			get_linesegs_twopts_on_asketchline(abrush->brushpts[i], cell1,
				abrush->brushpts[i+1], cell2, lineid, traj);
			lineid=traj->nlinesegs;
		}
	}

	/*  we need to judge whether it is a closed tensor line  */
	line_dir.entry[0]=traj->linesegs[0].gstart[0]-
		traj->linesegs[traj->nlinesegs-1].gend[0];
	line_dir.entry[1]=traj->linesegs[0].gstart[1]-
		traj->linesegs[traj->nlinesegs-1].gend[1];

	traj->closed=false;

	if(length(line_dir)<1.e-2)
	{
		if(traj->nlinesegs>=traj->curMaxNumLinesegs)
		{
			traj->extend_line_segments(1);
		}
		traj->linesegs[traj->nlinesegs].gstart[0]=traj->linesegs[traj->nlinesegs-1].gend[0];
		traj->linesegs[traj->nlinesegs].gstart[1]=traj->linesegs[traj->nlinesegs-1].gend[1];
		traj->linesegs[traj->nlinesegs].gend[0]=traj->linesegs[0].gstart[0];
		traj->linesegs[traj->nlinesegs].gend[1]=traj->linesegs[0].gstart[1];
		traj->linesegs[traj->nlinesegs].Triangle_ID=traj->linesegs[traj->nlinesegs-1].Triangle_ID;
		line_dir.entry[0]=traj->linesegs[traj->nlinesegs].gstart[0]-
			traj->linesegs[traj->nlinesegs].gend[0];
		line_dir.entry[1]=traj->linesegs[traj->nlinesegs].gstart[1]-
			traj->linesegs[traj->nlinesegs].gend[1];
		traj->linesegs[traj->nlinesegs].length=length(line_dir);
		traj->nlinesegs++;

		traj->closed=true;
	}

	//if(!sharedvars.rdSketchMajorHighways)
	//{
	//	major_level1->evenstreamlines->append(traj);
	//}
	//else
	traj->is_mapboundary=false;
		sketchlines->append(traj);
}

/*
   If currently, user chooses to design major roads, we copy the content in the sketchlines
   to the major_level1 variable
*/
void copy_sketchlines_to_major_level1()
{
	if(major_level1==NULL) return;

	if(sharedvars.UseMajRoadsAsSketchesOn && majorroadsexisted)
		return;

	/*  may contain some bugs  12/28/2007   */
	//major_level1->evenstreamlines->ntrajs=0;
	//minor_level1->evenstreamlines->ntrajs=0;

	/*  we also need to judge whether most parts of a sketch curve are "in the water"  */

	/*  we first copy the trajectories   */
	int i, j;
	int nroadscopy;
	if(sharedvars.UseMajRoadsAsSketchesOn && majorroadsexisted)
	{
		/*  copy to the major_level1  */

		/*  copy to the minor_level1  */
	}

	else
	{
		for(i=0;i<sketchlines->ntrajs;i++)
		{
			if(sketchlines->trajs[i]->is_mapboundary
				&&!sharedvars.UseBoundsAsRoadsOn)
				continue;

			Trajectory *traj=new Trajectory(sketchlines->trajs[i]->index,
				sketchlines->trajs[i]->nlinesegs);
			for(j=0;j<sketchlines->trajs[i]->nlinesegs;j++)
			{
				traj->linesegs[j].gstart[0]=sketchlines->trajs[i]->linesegs[j].gstart[0];
				traj->linesegs[j].gstart[1]=sketchlines->trajs[i]->linesegs[j].gstart[1];
				traj->linesegs[j].gend[0]=sketchlines->trajs[i]->linesegs[j].gend[0];
				traj->linesegs[j].gend[1]=sketchlines->trajs[i]->linesegs[j].gend[1];
				traj->linesegs[j].Triangle_ID=sketchlines->trajs[i]->linesegs[j].Triangle_ID;
				traj->linesegs[j].length=sketchlines->trajs[i]->linesegs[j].length;
			}
			traj->nlinesegs=sketchlines->trajs[i]->nlinesegs;
			traj->roadtype=MAJOR;
			traj->is_mapboundary=sketchlines->trajs[i]->is_mapboundary;

			major_level1->evenstreamlines->append(traj);
		}
	}

	//major_level1->evenstreamlines->ntrajs=sketchlines->ntrajs;

	/*  secondly, we need to update the information in each cell they pass  */
	//major_level1->rebuild_all_lineinfo();
}


/*
   We copy the first level of major roads to the sketchlines 12/28/2007
*/
void convert_majRoads_to_sketches()
{
	if(major_level1==NULL || minor_level1==NULL) return;

	/*  we also need to judge whether most parts of a sketch curve are "in the water"  */

	int i, j;

	/*   major direction  */
	for(i=0;i<major_level1->evenstreamlines->ntrajs;i++)
	{
		Trajectory *traj=new Trajectory(sketchlines->ntrajs,
			major_level1->evenstreamlines->trajs[i]->nlinesegs+1);
		for(j=0;j<major_level1->evenstreamlines->trajs[i]->nlinesegs;j++)
		{
			traj->linesegs[j].gstart[0]=
				major_level1->evenstreamlines->trajs[i]->linesegs[j].gstart[0];
			traj->linesegs[j].gstart[1]=
				major_level1->evenstreamlines->trajs[i]->linesegs[j].gstart[1];
			traj->linesegs[j].gend[0]=
				major_level1->evenstreamlines->trajs[i]->linesegs[j].gend[0];
			traj->linesegs[j].gend[1]=
				major_level1->evenstreamlines->trajs[i]->linesegs[j].gend[1];
			traj->linesegs[j].Triangle_ID=
				major_level1->evenstreamlines->trajs[i]->linesegs[j].Triangle_ID;
			traj->linesegs[j].length=
				major_level1->evenstreamlines->trajs[i]->linesegs[j].length;
		}
		traj->nlinesegs=major_level1->evenstreamlines->trajs[i]->nlinesegs;
		traj->is_mapboundary=false;
		traj->closed=major_level1->evenstreamlines->trajs[i]->closed;

		sketchlines->append(traj);
	}

	nRoads_majDir = major_level1->evenstreamlines->ntrajs;

	/*  minor direction  */
	for(i=0;i<minor_level1->evenstreamlines->ntrajs;i++)
	{
		Trajectory *traj=new Trajectory(sketchlines->ntrajs,
			minor_level1->evenstreamlines->trajs[i]->nlinesegs+1);
		for(j=0;j<minor_level1->evenstreamlines->trajs[i]->nlinesegs;j++)
		{
			traj->linesegs[j].gstart[0]=
				minor_level1->evenstreamlines->trajs[i]->linesegs[j].gstart[0];
			traj->linesegs[j].gstart[1]=
				minor_level1->evenstreamlines->trajs[i]->linesegs[j].gstart[1];
			traj->linesegs[j].gend[0]=
				minor_level1->evenstreamlines->trajs[i]->linesegs[j].gend[0];
			traj->linesegs[j].gend[1]=
				minor_level1->evenstreamlines->trajs[i]->linesegs[j].gend[1];
			traj->linesegs[j].Triangle_ID=
				minor_level1->evenstreamlines->trajs[i]->linesegs[j].Triangle_ID;
			traj->linesegs[j].length=
				minor_level1->evenstreamlines->trajs[i]->linesegs[j].length;
		}
		traj->nlinesegs=minor_level1->evenstreamlines->trajs[i]->nlinesegs;
		traj->is_mapboundary=false;
		traj->closed=minor_level1->evenstreamlines->trajs[i]->closed;

		sketchlines->append(traj);
	}

}


/*  Update the information of the mesh:
    Update a list for each cell that those sketch curves pass
*/

void update_sketchcurveinfo_oneline(int sketchlineid)
{
	/*we need to update the line information for each cell of the mesh 10/02/2007*/
	int i;
	Trajectory *cur_traj = sketchlines->trajs[sketchlineid];
	int pre_cell = cur_traj->linesegs[0].Triangle_ID;
	int start, end;
	start = end = 0;
	for(i=1; i<cur_traj->nlinesegs; i++)
	{
		if(cur_traj->linesegs[i].Triangle_ID == pre_cell)
		{
			end = i;
			continue;
		}
		else{
			LinesInOneCell *newline = (LinesInOneCell*)malloc(sizeof(LinesInOneCell));
			newline->whichtraj = sketchlineid;
			newline->start = start;
			newline->end = end;
			QuadCell *curc = quadmesh->quadcells[pre_cell];

			if(curc->sketchlines == NULL)
				curc->sketchlines = new LineInfo(1);
			if(!curc->sketchlines->is_repeated(newline))
				curc->sketchlines->addNew(newline);
			else
				free(newline);
			start = end = i;
			pre_cell = cur_traj->linesegs[i].Triangle_ID;

			if(pre_cell<0||pre_cell>=quadmesh->nfaces)
				break;
		}
	}

	/*we need to handle the last line segments*/
	start = end = cur_traj->nlinesegs-1;
	pre_cell = cur_traj->linesegs[start].Triangle_ID;

	if(pre_cell<0||pre_cell>=quadmesh->nfaces)
		return;

	for(i=cur_traj->nlinesegs-2; i>=0; i--)
	{
		if(cur_traj->linesegs[i].Triangle_ID == pre_cell)
		{
			start = i;
			continue;
		}
		else{
			LinesInOneCell *newline = (LinesInOneCell*)malloc(sizeof(LinesInOneCell));
			newline->whichtraj = sketchlineid;
			newline->start = start;
			newline->end = end;
			QuadCell *curc = quadmesh->quadcells[pre_cell];

			if(curc->sketchlines == NULL)
				curc->sketchlines = new LineInfo(1);
			if(!curc->sketchlines->is_repeated(newline))
				curc->sketchlines->addNew(newline);
			else
				free(newline);

			start = end = i;
			pre_cell = cur_traj->linesegs[i].Triangle_ID;
			break;
		}
	}
}


/*
       Call this routine to update the trajectory information of each cell according to the
	   each sketch curve 
*/
void update_sketchcurveinfo()
{
	int i;
	for(i=0;i<sketchlines->ntrajs;i++)
		update_sketchcurveinfo_oneline(i);
}

/***********************/
/*  find the intersection after updating the mesh according to the sketch line
*/
extern int cal_intersect(double PointA[2], double PointB[2], 
				  double PointC[2], double PointD[2], double t[2]);

/*we now use brute force method to find out the intersections*/
bool compute_intersect_between_twosketchlines(int majtraj, int majstart, int majend,
										int mintraj, int minstart, int minend,
										double intersect[2], 
										int &majlinesegid, int &minlinesegid)
{
	int i, j;
	Trajectory *major1, *minor1;
	double A[2], B[2], C[2], D[2], t[2];
	major1=sketchlines->trajs[majtraj];
	minor1=sketchlines->trajs[mintraj];
	//for(i=majstart; i<=majend; i++)
	for(i=max(majstart-1, 0); i<=min(majend, major1->nlinesegs-1); i++)
	{
		A[0]=major1->linesegs[i].gstart[0];
		A[1]=major1->linesegs[i].gstart[1];
		B[0]=major1->linesegs[i].gend[0];
		B[1]=major1->linesegs[i].gend[1];

		//for(j=minstart; j<=minend; j++)
		for(j=max(minstart-1,0); j<=min(minend, minor1->nlinesegs-1); j++)
		{
			C[0]=minor1->linesegs[j].gstart[0];
			C[1]=minor1->linesegs[j].gstart[1];
			D[0]=minor1->linesegs[j].gend[0];
			D[1]=minor1->linesegs[j].gend[1];

			//if(GetIntersection2(A, B, C, D, t)==1)
			if(cal_intersect(A, B, C, D, t)==1)
			{
				intersect[0]=A[0]+t[0]*(B[0]-A[0]);
				intersect[1]=A[1]+t[0]*(B[1]-A[1]);
				majlinesegid = i;
				minlinesegid = j;
				return true;
			}
		}
	}
	return false;
}


/*we compute the intersections in a particular cell*/
void compute_sketchlineintersects_in_cell(int cellid)
{
	QuadCell *face = quadmesh->quadcells[cellid];

	/*method 1: we use brute force method 10/02/2007*/
	int i, j;
	int majlinesegid, minlinesegid;
	double intersect[2] = {0.};
	
	//if(cellid==5156 || cellid==5157 || cellid==5101)
	//{
	//	int test=0;
	//}

	/*Test file*/
	FILE *fp;
	int foundcount=0;

	for(i=0; i<face->sketchlines->nlines; i++)
	{
		for(j=i+1; j<face->sketchlines->nlines; j++)
		{
			if(compute_intersect_between_twosketchlines(face->sketchlines->lines[i]->whichtraj,
				face->sketchlines->lines[i]->start, face->sketchlines->lines[i]->end,
				face->sketchlines->lines[j]->whichtraj,
				face->sketchlines->lines[j]->start, face->sketchlines->lines[j]->end,
				intersect, majlinesegid, minlinesegid))
			{
				/*create a new intersection data*/
				Intersection *newintersect=(Intersection*)malloc(sizeof(Intersection));
				newintersect->gpos[0]=intersect[0];
				newintersect->gpos[1]=intersect[1];
				newintersect->cellid=cellid;
				newintersect->majorline_id=face->sketchlines->lines[i]->whichtraj;
				newintersect->minorline_id=face->sketchlines->lines[j]->whichtraj;
				newintersect->majlineseg=majlinesegid;
				newintersect->minlineseg=minlinesegid;
				newintersect->nadjedges=0;
				newintersect->adj_edges=NULL;
				newintersect->endpt=false;

				sketchnet->nodelist->addNew(newintersect);

				/*add to the corresponding tensor line intersection lists (major/minor)*/
				IntersectionInfo *majinfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				majinfo->intersect_id=sketchnet->nodelist->nelems-1;
				majinfo->lineseg_id = majlinesegid;
				sketchlineintersectinfo[newintersect->majorline_id]->sorted_add(majinfo);

				IntersectionInfo *mininfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				mininfo->intersect_id=sketchnet->nodelist->nelems-1;
				mininfo->lineseg_id = minlinesegid;
				sketchlineintersectinfo[newintersect->minorline_id]->sorted_add(mininfo);

				foundcount++;
			}
		}
	}

	if(foundcount==0)
	{
		int test=0;
	}
}


/*
       Calculate the intersections on the four boundaries of the rectangular region
*/
void cal_boundary_intersects()
{
	/*  add the four vertices of the rectangular region into the intersection list  */

	/*  bottom left  */
	Intersection *bottomleft=(Intersection*)malloc(sizeof(Intersection));
	bottomleft->gpos[0]=quadmesh->xstart+1.e-6;
	bottomleft->gpos[1]=quadmesh->ystart+1.e-6;
	bottomleft->cellid=0;
	bottomleft->majorline_id=0;
	bottomleft->minorline_id=3;
	bottomleft->majlineseg=0;
	bottomleft->minlineseg=0;
	bottomleft->nadjedges=0;
	bottomleft->adj_edges=NULL;
	bottomleft->endpt=false;
	sketchnet->nodelist->addNew(bottomleft);

	/*  bottom right */
	Intersection *bottomright=(Intersection*)malloc(sizeof(Intersection));
	bottomright->gpos[0]=quadmesh->xend-1.e-6;
	bottomright->gpos[1]=quadmesh->ystart+1.e-6;
	bottomright->cellid=quadmesh->XDIM-1;
	bottomright->majorline_id=0;
	bottomright->minorline_id=1;
	bottomright->majlineseg=quadmesh->XDIM-2;
	bottomright->minlineseg=0;
	bottomright->nadjedges=0;
	bottomright->adj_edges=NULL;
	bottomright->endpt=false;
	sketchnet->nodelist->addNew(bottomright);
	
	/*  upper left */
	Intersection *upperleft=(Intersection*)malloc(sizeof(Intersection));
	upperleft->gpos[0]=quadmesh->xstart+1.e-6;
	upperleft->gpos[1]=quadmesh->yend-1.e-6;
	upperleft->cellid=quadmesh->nfaces-quadmesh->XDIM+1;
	upperleft->majorline_id=2;
	upperleft->minorline_id=3;
	upperleft->majlineseg=0;
	upperleft->minlineseg=quadmesh->XDIM-2;
	upperleft->nadjedges=0;
	upperleft->adj_edges=NULL;
	upperleft->endpt=false;
	sketchnet->nodelist->addNew(upperleft);
	
	/*  upper right */
	Intersection *upperright=(Intersection*)malloc(sizeof(Intersection));
	upperright->gpos[0]=quadmesh->xend-1.e-6;
	upperright->gpos[1]=quadmesh->yend-1.e-6;
	upperright->cellid=quadmesh->nfaces-1;
	upperright->majorline_id=2;
	upperright->minorline_id=1;
	upperright->majlineseg=quadmesh->XDIM-2;
	upperright->minlineseg=quadmesh->XDIM-2;
	upperright->nadjedges=0;
	upperright->adj_edges=NULL;
	upperright->endpt=false;
	sketchnet->nodelist->addNew(upperright);

	/*   search the end point of each sketch curve to find out
	     the possible intersections with the four boundaries 
	*/
	int i, j;
	LineSeg *curline;
	double endp[2];
	for(i=0;i<sketchlines->ntrajs;i++)
	{
		/*   start point   */
		for(j=0;j<2;j++)
		{
			if(j==0)
			{
				curline=&sketchlines->trajs[i]->linesegs[0];
				endp[0]=curline->gstart[0];
				endp[1]=curline->gstart[1];
			}
			else
			{
				curline=&sketchlines->trajs[i]->linesegs[sketchlines->trajs[i]->nlinesegs-1];
				endp[0]=curline->gend[0];
				endp[1]=curline->gend[1];
			}

			if(fabs(endp[1]-quadmesh->ystart)<5.e-6) /*bottom*/
			{
				Intersection *newintersect=(Intersection *)malloc(sizeof(Intersection));
				newintersect->gpos[0]=endp[0];
				newintersect->gpos[1]=endp[1];
				newintersect->cellid=curline->Triangle_ID;
				newintersect->majorline_id=i;
				newintersect->minorline_id=0; /*bottom line*/
				newintersect->majlineseg=j*(sketchlines->trajs[i]->nlinesegs-1);
				newintersect->minlineseg=curline->Triangle_ID;
				newintersect->nadjedges=0;
				newintersect->adj_edges=NULL;
				newintersect->endpt=false;
				sketchnet->nodelist->addNew(newintersect);

				IntersectionInfo *majinfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				majinfo->intersect_id=sketchnet->nodelist->nelems-1;
				majinfo->lineseg_id = newintersect->majlineseg;
				sketchlineintersectinfo[newintersect->majorline_id]->sorted_add(majinfo);

				IntersectionInfo *mininfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				mininfo->intersect_id=sketchnet->nodelist->nelems-1;
				mininfo->lineseg_id = newintersect->minlineseg;
				domainboundintersectinfo[newintersect->minorline_id]->sorted_add(mininfo);
			}
			else if(fabs(endp[0]-quadmesh->xend)<5.e-6) /*right*/
			{
				Intersection *newintersect=(Intersection *)malloc(sizeof(Intersection));
				newintersect->gpos[0]=endp[0];
				newintersect->gpos[1]=endp[1];
				newintersect->cellid=curline->Triangle_ID;
				newintersect->majorline_id=i;
				newintersect->minorline_id=1; /*right line*/
				newintersect->majlineseg=j*(sketchlines->trajs[i]->nlinesegs-1);
				newintersect->minlineseg=(int)(curline->Triangle_ID/(quadmesh->XDIM-1));
				newintersect->nadjedges=0;
				newintersect->adj_edges=NULL;
				newintersect->endpt=false;
				sketchnet->nodelist->addNew(newintersect);

				IntersectionInfo *majinfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				majinfo->intersect_id=sketchnet->nodelist->nelems-1;
				majinfo->lineseg_id = newintersect->majlineseg;
				sketchlineintersectinfo[newintersect->majorline_id]->sorted_add(majinfo);

				IntersectionInfo *mininfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				mininfo->intersect_id=sketchnet->nodelist->nelems-1;
				mininfo->lineseg_id = newintersect->minlineseg;
				domainboundintersectinfo[newintersect->minorline_id]->sorted_add(mininfo);
			}

			else if(fabs(endp[1]-quadmesh->yend)<5.e-6) /*upper*/
			{
				Intersection *newintersect=(Intersection *)malloc(sizeof(Intersection));
				newintersect->gpos[0]=endp[0];
				newintersect->gpos[1]=endp[1];
				newintersect->cellid=curline->Triangle_ID;
				newintersect->majorline_id=i;
				newintersect->minorline_id=2; /*upper line*/
				newintersect->majlineseg=j*(sketchlines->trajs[i]->nlinesegs-1);
				newintersect->minlineseg=quadmesh->XDIM-(quadmesh->nfaces-curline->Triangle_ID);
				newintersect->nadjedges=0;
				newintersect->adj_edges=NULL;
				newintersect->endpt=false;
				sketchnet->nodelist->addNew(newintersect);

				IntersectionInfo *majinfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				majinfo->intersect_id=sketchnet->nodelist->nelems-1;
				majinfo->lineseg_id = newintersect->majlineseg;
				sketchlineintersectinfo[newintersect->majorline_id]->sorted_add(majinfo);

				IntersectionInfo *mininfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				mininfo->intersect_id=sketchnet->nodelist->nelems-1;
				mininfo->lineseg_id = newintersect->minlineseg;
				domainboundintersectinfo[newintersect->minorline_id]->sorted_add(mininfo);
			}

			else if(fabs(endp[0]-quadmesh->xstart)<5.e-6) /*left*/
			{
				Intersection *newintersect=(Intersection *)malloc(sizeof(Intersection));
				newintersect->gpos[0]=endp[0];
				newintersect->gpos[1]=endp[1];
				newintersect->cellid=curline->Triangle_ID;
				newintersect->majorline_id=i;
				newintersect->minorline_id=3; /*left line*/
				newintersect->majlineseg=j*(sketchlines->trajs[i]->nlinesegs-1);
				newintersect->minlineseg=(int)(curline->Triangle_ID/(quadmesh->XDIM-1));
				newintersect->nadjedges=0;
				newintersect->adj_edges=NULL;
				newintersect->endpt=false;
				sketchnet->nodelist->addNew(newintersect);

				IntersectionInfo *majinfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				majinfo->intersect_id=sketchnet->nodelist->nelems-1;
				majinfo->lineseg_id = newintersect->majlineseg;
				sketchlineintersectinfo[newintersect->majorline_id]->sorted_add(majinfo);

				IntersectionInfo *mininfo=(IntersectionInfo*)malloc(sizeof(IntersectionInfo));
				mininfo->intersect_id=sketchnet->nodelist->nelems-1;
				mininfo->lineseg_id = newintersect->minlineseg;
				domainboundintersectinfo[newintersect->minorline_id]->sorted_add(mininfo);
			}
		}
	}
}


/*
         After updating the sketch curve information in the cells they pass,
		 we compute the intersections between those sketch curve.
 */
void cal_sketchlines_intersects()
{
	/*we first locate the cells that may contain intersections*/
	
	/*  compute the intersections on the domain boudaries */
	cal_boundary_intersects();

	int i;
	QuadCell *face;
	for(i=0; i<quadmesh->nfaces; i++)
	{
		face = quadmesh->quadcells[i];

		if(face->sketchlines!=NULL&&face->sketchlines->nlines>=2)
			compute_sketchlineintersects_in_cell(i);
	}
}


extern int *extend_link(int *edge_link, int Num_edges);

void add_edge_to_sketch_intersect(int node, int edgeindex)
{
	if(node < 0)
		return;

	sketchnet->nodelist->intersects[node]->adj_edges = 
		extend_link(sketchnet->nodelist->intersects[node]->adj_edges,
		sketchnet->nodelist->intersects[node]->nadjedges);

	sketchnet->nodelist->intersects[node]->adj_edges[
		sketchnet->nodelist->intersects[node]->nadjedges] = edgeindex;
	sketchnet->nodelist->intersects[node]->nadjedges++;
}



/*
      Search the obtained intersection info list to construct a graph
*/
void search_for_sketchbased_graph()
{
	/*we can simply search the two groups of the intersection lists once
	and construct the edges*/
	int i, j;
	TensorLineIntersectionInfoList *infolist;
	IntersectionInfo *info, *infonext;
	Trajectory *traj;
	int start_lineseg, end_lineseg;
	double startp[2], endp[2];

	/*    search the boundaries    */
	for(i=0; i<domainboundaries->ntrajs; i++)
	{
		infolist=domainboundintersectinfo[i];

		traj=domainboundaries->trajs[i];

		for(j=0; j<infolist->nelems-1; j++)
		{
			info = infolist->infolist[j];
			infonext = infolist->infolist[j+1];

			/*build connection between it and its succeeding*/

			/*we use new data structure for the street network 11/06/2007*/
			StreetGraphEdge *newedge = (StreetGraphEdge*)malloc(sizeof(StreetGraphEdge));
			newedge->node_index1 = info->intersect_id;
			newedge->node_index2 = infonext->intersect_id;
			newedge->cancel = newedge->visited = false;
			newedge->inter_pts = NULL; //we will add the intermediate points later
			newedge->ninter_pts = 0;
			sketchnet->edgelist->append(newedge);

			/* resample the line and record the information into the 
			corresponding line  11/26/2007 */
			start_lineseg=info->lineseg_id;
			end_lineseg=infonext->lineseg_id;

			startp[0]=sketchnet->nodelist->intersects[info->intersect_id]->gpos[0];
			startp[1]=sketchnet->nodelist->intersects[info->intersect_id]->gpos[1];
			endp[0]=sketchnet->nodelist->intersects[infonext->intersect_id]->gpos[0];
			endp[1]=sketchnet->nodelist->intersects[infonext->intersect_id]->gpos[1];

			sample_along_tensorline_from_to(traj, start_lineseg, startp,
									 end_lineseg, endp, 
									 newedge->index, sketchnet);

			/**/
			add_edge_to_sketch_intersect(info->intersect_id, newedge->index);
			add_edge_to_sketch_intersect(infonext->intersect_id, newedge->index);
		}
	}

	/*    search the obtained sketch curves    */
	for(i=0; i<sketchlines->ntrajs; i++)
	{
		infolist=sketchlineintersectinfo[i];
		traj=sketchlines->trajs[i];

		for(j=0; j<infolist->nelems-1; j++)
		{
			info = infolist->infolist[j];
			infonext = infolist->infolist[j+1];

			/*build connection between it and its succeeding*/

			/*we use new data structure for the street network 11/06/2007*/
			StreetGraphEdge *newedge = (StreetGraphEdge*)malloc(sizeof(StreetGraphEdge));
			newedge->node_index1 = info->intersect_id;
			newedge->node_index2 = infonext->intersect_id;
			newedge->cancel = newedge->visited = false;
			newedge->inter_pts = NULL; //we will add the intermediate points later
			newedge->ninter_pts = 0;
			sketchnet->edgelist->append(newedge);

			/* resample the line and record the information into the 
			corresponding line  11/26/2007 */
			start_lineseg=info->lineseg_id;
			end_lineseg=infonext->lineseg_id;

			startp[0]=sketchnet->nodelist->intersects[info->intersect_id]->gpos[0];
			startp[1]=sketchnet->nodelist->intersects[info->intersect_id]->gpos[1];
			endp[0]=sketchnet->nodelist->intersects[infonext->intersect_id]->gpos[0];
			endp[1]=sketchnet->nodelist->intersects[infonext->intersect_id]->gpos[1];

			sample_along_tensorline_from_to(traj, start_lineseg, startp,
									 end_lineseg, endp, 
									 newedge->index, sketchnet);
			/**/
			add_edge_to_sketch_intersect(info->intersect_id, newedge->index);
			add_edge_to_sketch_intersect(infonext->intersect_id, newedge->index);
		}
	}
}


/*
     extend the end points of each sketch curve to avoid dead end
	 We either extend the curve to intersect with one other curve
	 or intersect with one of the domain boundaries
*/

void extend_sketchcurves()
{
	int i;

	/*we copy the original sketch curves into a temporary list*/
	if(t_sketchlines != NULL)
		delete t_sketchlines;
		
	t_sketchlines=new TrajectoryList(sketchlines->ntrajs);

	for(i=0;i<t_sketchlines->curMaxNumTrajs;i++)
	{
		if(t_sketchlines->trajs[i]==NULL)
			t_sketchlines->trajs[i]=new Trajectory(i, sketchlines->trajs[i]->curMaxNumLinesegs);

		t_sketchlines->trajs[i]->nlinesegs=0;
	}


	for(i=0;i<sketchlines->ntrajs;i++)
	{
		t_sketchlines->trajs[i]->add_front_nlines(sketchlines->trajs[i]->linesegs,
			sketchlines->trajs[i]->nlinesegs);
		t_sketchlines->trajs[i]->closed=sketchlines->trajs[i]->closed;
	}

	for(i=0;i<sketchlines->ntrajs;i++)
		extend_one_sketchcurve(i);

	/*copy back to the original variable*/
	for(i=0;i<sketchlines->ntrajs;i++)
	{
		sketchlines->trajs[i]->nlinesegs=0;
		sketchlines->trajs[i]->add_front_nlines(t_sketchlines->trajs[i]->linesegs,
			t_sketchlines->trajs[i]->nlinesegs);
	}

	/*   copy to the major roads 12/26/2007  */
	if(!sharedvars.rdSketchMajorHighways)
	{
		//major_level1
	}
}


bool find_middlePt_traj_in_one_cell(int trajid, int cellid, double pt[2])
{
	int i;
	int start, end;
	bool found=false;
	Trajectory *traj=sketchlines->trajs[trajid];

	for(i=0;i<traj->nlinesegs;i++)
	{
		if(traj->linesegs[i].Triangle_ID==cellid && !found)
		{
			found=true;
			start=end=i;
		}
		else if(traj->linesegs[i].Triangle_ID==cellid)
		{
			end=i;
		}
	}

	if(!found)
		return false;
	
	LineSeg *theline=&traj->linesegs[(int)(start+end)/2];
	pt[0]=(theline->gend[0]+theline->gstart[0])/2.;
	pt[1]=(theline->gend[1]+theline->gstart[1])/2.;
	return true;
}


/*
   extend one sketch curve.
   NOTE: the extending process should stop when it reaches a not "inland" point!
*/

void extend_one_sketchcurve(int id)
{
	Trajectory *traj=t_sketchlines->trajs[id];
	if(traj->nlinesegs==0) return;

	if(traj->closed) return;  /*  if it is a closed brush, leave it there 12/24/2007  */


	Trajectory *temp=new Trajectory(-1); /*we may need it to extend the sketch curve*/
	Trajectory *temp2=new Trajectory(-1); /*we may need it to extend the sketch curve*/

	int cur_cell=traj->linesegs[0].Triangle_ID;
	QuadCell *face=quadmesh->quadcells[cur_cell];
	icVector2 dist;
	Intersection *intersect;
	LineSeg *curline=&traj->linesegs[0];
	//int nobtainedlines;

	//FILE *fp=fopen("lineseg_endpts.txt", "a");
	//fprintf(fp, "Traj %d:\n", id);
	//fprintf(fp, "start pt: (%f, %f)\n", traj->linesegs[0].gstart[0], traj->linesegs[0].gstart[1]);
	//fprintf(fp, "end pt:   (%f, %f)\n", traj->linesegs[traj->nlinesegs-1].gend[0],
	//	traj->linesegs[traj->nlinesegs-1].gend[1]);
	//fclose(fp);

	int other_lineid;

	/*          Deal with the start poing         */

	if(traj->linesegs[0].gstart[0]<=quadmesh->xstart+1.e-8
		||traj->linesegs[0].gstart[0]>=quadmesh->xend-1.e-8
		||traj->linesegs[0].gstart[1]<=quadmesh->ystart+1.e-8
		||traj->linesegs[0].gstart[1]>=quadmesh->yend-1.e-8)
	{
		if(traj->linesegs[0].gstart[0]<=quadmesh->xstart+1.e-8)
			traj->linesegs[0].gstart[0]=quadmesh->xstart/*+1.e-8*/;
		else if(traj->linesegs[0].gstart[0]>=quadmesh->xend-1.e-8)
			traj->linesegs[0].gstart[0]=quadmesh->xend/*-1.e-8*/;
		if(traj->linesegs[0].gstart[1]<=quadmesh->ystart+1.e-8)
			traj->linesegs[0].gstart[1]=quadmesh->ystart/*+1.e-8*/;
		else if(traj->linesegs[0].gstart[1]>=quadmesh->yend-1.e-8)
			traj->linesegs[0].gstart[1]=quadmesh->yend/*-1.e-8*/;
	}

	/*if the cell containing the first point of the sketch 
	contains other sketch curve*/
	else if(face->sketchlines!=NULL && face->sketchlines->nlines>=2)
	{
		/*if the end point is not the intersection*/
		for(int j=0;j<face->sketchlines->nlines;j++)
		{
			/*  find the other line to compute the intersection  */
			if(face->sketchlines->lines[j]->whichtraj!=id)
			{
				other_lineid=face->sketchlines->lines[j]->whichtraj;
				break;
			}
		}

		//intersect=sketchnet->nodelist->intersects[
		////sketchlineintersectinfo[id]->infolist[0]->intersect_id];
		//sketchlineintersectinfo[other_lineid]->infolist[0]->intersect_id];
		//	
		//dist.entry[0]=intersect->gpos[0]-traj->linesegs[0].gstart[0];
		//dist.entry[1]=intersect->gpos[1]-traj->linesegs[0].gstart[1];

		//if(length(dist)>1.e-4)
		//{
		//	/*add one new line segment*/
		//	temp->linesegs[0].gstart[0]=intersect->gpos[0];
		//	temp->linesegs[0].gstart[1]=intersect->gpos[1];
		//	temp->linesegs[0].gend[0]=traj->linesegs[0].gstart[0];
		//	temp->linesegs[0].gend[1]=traj->linesegs[0].gstart[1];
		//	temp->linesegs[0].Triangle_ID=traj->linesegs[0].Triangle_ID;
		//	temp->nlinesegs=1;
		//}

		double pt[2];
		if(find_middlePt_traj_in_one_cell(other_lineid, face->index, pt))
		{
			/*add one new line segment*/
			icVector2 line_dir1, line_dir2;
			line_dir1.entry[0]=traj->linesegs[0].gstart[0]-traj->linesegs[0].gend[0];
			line_dir1.entry[1]=traj->linesegs[0].gstart[1]-traj->linesegs[0].gend[1];

			line_dir2.entry[0]=pt[0]-traj->linesegs[0].gstart[0];
			line_dir2.entry[1]=pt[1]-traj->linesegs[0].gstart[1];

			if(dot(line_dir1, line_dir2)>0)
			{
				temp->linesegs[0].gstart[0]=pt[0];
				temp->linesegs[0].gstart[1]=pt[1];
				temp->linesegs[0].gend[0]=traj->linesegs[0].gstart[0];
				temp->linesegs[0].gend[1]=traj->linesegs[0].gstart[1];
				temp->linesegs[0].Triangle_ID=traj->linesegs[0].Triangle_ID;
				temp->nlinesegs=1;
			}
			else
			{
				goto LS1;
			}
		}
	}


	/*if the end point is on the boundary of the domain*/
	//else if(fabs(traj->linesegs[0].gstart[0]-quadmesh->xstart)<1.e-8
	//	||fabs(traj->linesegs[0].gstart[0]-quadmesh->xend)<1.e-8
	//	||fabs(traj->linesegs[0].gstart[1]-quadmesh->ystart)<1.e-8
	//	||fabs(traj->linesegs[0].gstart[1]-quadmesh->yend)<1.e-8)
	//{
	//}
	

	else /*general case*/
	{
		/*we trace starting from traj->linesegs[0].gstart following certain
		direction, until: 1) it reaches a cell that contains other sketch curve;
		2) it reaches a domain boundary*/

		/*  obtain an approximation direction  */
LS1:		
		icVector2 dir;
		dir.set(0.);
		for(int i=0; i<min(6, traj->nlinesegs); i++)
		{
			icVector2 temp_v;
			temp_v.entry[0]=traj->linesegs[i].gstart[0]-traj->linesegs[i].gend[0];
			temp_v.entry[1]=traj->linesegs[i].gstart[1]-traj->linesegs[i].gend[1];
			dir=dir+temp_v;
		}
		normalize(dir);

		get_linesegs_extendskecthcurve(id, curline->gend, curline->Triangle_ID,
			curline->gstart, curline->Triangle_ID, dir, /*nobtainedlines,*/ temp, 0);

		/*we need to reverse the obtain trajectory!  11/25/2007*/
		temp->reverse_lines();
	}

	/*                                            */
	/*          Deal with the end point similarly         */
	curline=&traj->linesegs[traj->nlinesegs-1];
	cur_cell=curline->Triangle_ID;
	face=quadmesh->quadcells[cur_cell];

	if(curline->gend[0]<=quadmesh->xstart+1.e-8
		||curline->gend[0]>=quadmesh->xend-1.e-8
		||curline->gend[1]<=quadmesh->ystart+1.e-8
		||curline->gend[1]>=quadmesh->yend-1.e-8)
	{
		if(curline->gend[0]<=quadmesh->xstart+1.e-8)
			curline->gend[0]=quadmesh->xstart/*+1.e-8*/;
		else if(curline->gend[0]>=quadmesh->xend-1.e-8)
			curline->gend[0]=quadmesh->xend/*-1.e-8*/;
		if(curline->gend[1]<=quadmesh->ystart+1.e-8)
			curline->gend[1]=quadmesh->ystart/*+1.e-8*/;
		else if(curline->gend[1]>=quadmesh->yend-1.e-8)
			curline->gend[1]=quadmesh->yend/*-1.e-8*/;
	}
	/*if the cell containing the first point of the sketch 
	contains other sketch curve*/
	else if(face->sketchlines!=NULL && face->sketchlines->nlines>=2)
	{
		/*if the end point is not the intersection*/
		for(int j=0;j<face->sketchlines->nlines;j++)
		{
			/*  find the other line to compute the intersection  */
			if(face->sketchlines->lines[j]->whichtraj!=id)
			{
				other_lineid=face->sketchlines->lines[j]->whichtraj;
				break;
			}
		}

		//intersect=sketchnet->nodelist->intersects[
		////sketchlineintersectinfo[id]->infolist[0]->intersect_id];
		//sketchlineintersectinfo[other_lineid]->infolist[0]->intersect_id];
		//	
		//dist.entry[0]=intersect->gpos[0]-curline->gstart[0];
		//dist.entry[1]=intersect->gpos[1]-curline->gstart[1];

		//if(length(dist)>1.e-4)
		//{
		//	/*add one new line segment*/
		//	temp2->linesegs[0].gstart[0]=intersect->gpos[0];
		//	temp2->linesegs[0].gstart[1]=intersect->gpos[1];
		//	temp2->linesegs[0].gend[0]=curline->gstart[0];
		//	temp2->linesegs[0].gend[1]=curline->gstart[1];
		//	temp2->linesegs[0].Triangle_ID=curline->Triangle_ID;
		//	temp2->nlinesegs=1;
		//}

		double pt[2];
		if(find_middlePt_traj_in_one_cell(other_lineid, face->index, pt))
		{
			/*add one new line segment*/
			icVector2 line_dir1, line_dir2;
			line_dir1.entry[0]=curline->gend[0]-curline->gstart[0];
			line_dir1.entry[1]=curline->gend[1]-curline->gstart[1];

			line_dir2.entry[0]=pt[0]-curline->gend[0];
			line_dir2.entry[1]=pt[1]-curline->gend[1];

			if(dot(line_dir1, line_dir2)>0)
			{
				temp->linesegs[0].gend[0]=pt[0];
				temp->linesegs[0].gend[1]=pt[1];
				temp->linesegs[0].gstart[0]=curline->gend[0];
				temp->linesegs[0].gstart[1]=curline->gend[1];
				temp->linesegs[0].Triangle_ID=curline->Triangle_ID;
				temp->nlinesegs=1;
			}
			else
			{
				goto LS2;
			}
		}
	}

	/*if the end point is on the boundary of the domain*/
	//else if(fabs(curline->gstart[0]-quadmesh->xstart)<1.e-6
	//	||fabs(curline->gstart[0]-quadmesh->xend)<1.e-6
	//	||fabs(curline->gstart[1]-quadmesh->ystart)<1.e-6
	//	||fabs(curline->gstart[1]-quadmesh->yend)<1.e-6)
	//{
	//}

	else /*general case*/
	{
		/*we trace starting from traj->linesegs[0].gstart following certain
		direction, until: 1) it reaches a cell that contains other sketch curve;
		2) it reaches a domain boundary*/
LS2:		
		icVector2 dir;
		dir.set(0.);
		for(int i=max(0, traj->nlinesegs-7); i<traj->nlinesegs; i++)
		{
			icVector2 temp_v;
			temp_v.entry[0]=traj->linesegs[i].gend[0]-traj->linesegs[i].gstart[0];
			temp_v.entry[1]=traj->linesegs[i].gend[1]-traj->linesegs[i].gstart[1];
			dir=dir+temp_v;
		}
		normalize(dir);

		get_linesegs_extendskecthcurve(id, curline->gstart, curline->Triangle_ID,
			curline->gend, curline->Triangle_ID, dir,/*nobtainedlines,*/ temp2, 0);
	}


	/*          Update the corresponding trajectory of the sketch curve          */

	/*we rearrange the whole line segment list including the head and the tail*/

	/*re-arrange the first n line segments*/
		/*we add new line segment(s) in the front*/
	traj->add_front_nlines(temp->linesegs, temp->nlinesegs);

	/*we add new line segment(s) in the end*/
	traj->add_last_nlines(temp2->linesegs, temp2->nlinesegs);
	
	delete temp2;
	delete temp;
}


bool is_skectch_pass_thecell(int cellid, int sketchid)
{
	QuadCell *face=quadmesh->quadcells[cellid];
	if(face->sketchlines==NULL)
		return false;

	int i;
	for(i=0;i<face->sketchlines->nlines;i++)
	{
		if(face->sketchlines->lines[i]->whichtraj==sketchid)
			return true;
	}
	return false;
}

/*
p1-->p2
*/

void get_linesegs_extendskecthcurve(int sketchid, double p1[2], int cell1, 
									double p2[2], int cell2, icVector2 dir, /*int lineid,*/
									/*int &nlines, */Trajectory *traj, int type)
{
	double pre_p[2]={p1[0], p1[1]};
	double cur_p[2]={p2[0], p2[1]};
	int i;
	int cur_cell = cell1;
	QuadCell *face;
	icVector2 linedir, line_dir2;
	//linedir.set((cur_p[0]-pre_p[0]),(cur_p[1]-pre_p[1]));
	linedir.set(dir);
	normalize(linedir);
	tenline_dir_global = linedir;

	cur_cell=cell1;

	icVector2 t_major[4];
	int count = 1;
	traj->nlinesegs=0;


	while(1)
	{
		/*judge whether it reaches the boundary or not*/
		//if(fabs(cur_p[0]-quadmesh->xstart)<1.e-6
		//	||fabs(cur_p[0]-quadmesh->xend)<1.e-6
		//	||fabs(cur_p[1]-quadmesh->ystart)<1.e-6
		//	||fabs(cur_p[1]-quadmesh->yend)<1.e-6)

		if(cur_p[0]<=quadmesh->xstart+1.e-8
			||cur_p[0]>=quadmesh->xend-1.e-8
			||cur_p[1]<=quadmesh->ystart+1.e-8
			||cur_p[1]>=quadmesh->yend-1.e-8)
		{
			/*compute the point on the boundary,
			  build a new line segment,
			  then, return
			*/

			//if(pre_p[0]<quadmesh->quadcells[cur_cell]->x_start_coord
			//	||pre_p[1]<quadmesh->quadcells[cur_cell]->y_start_coord
			//	||cur_p[0]>quadmesh->quadcells[cur_cell]->x_start_coord+quadmesh->xinterval
			//	||cur_p[1]>quadmesh->quadcells[cur_cell]->y_start_coord+quadmesh->yinterval)
			//	return;
			if(cur_p[0]<=quadmesh->xstart+1.e-8) cur_p[0]=quadmesh->xstart;
			else if(cur_p[0]>=quadmesh->xend-1.e-8) cur_p[0]=quadmesh->xend;
			if(cur_p[1]<=quadmesh->ystart+1.e-8) cur_p[1]=quadmesh->ystart;
			else if(cur_p[1]>=quadmesh->yend-1.e-8) cur_p[1]=quadmesh->yend;

			traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
			traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
			line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
				traj->linesegs[traj->nlinesegs].gstart[0];
			line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
				traj->linesegs[traj->nlinesegs].gstart[1];
			traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			traj->nlinesegs++;
			return;
		}

		/*if we reach a cell that contains other sketch curve, we stop and compute
		the intersection*/
		if(cur_cell>=0 && cur_cell<quadmesh->nfaces &&
			quadmesh->quadcells[cur_cell]->sketchlines!=NULL
			&& quadmesh->quadcells[cur_cell]->sketchlines->nlines>=1
			&& !is_skectch_pass_thecell(cur_cell, sketchid))
			break;

		/*     start moving    */
		pre_p[0]=cur_p[0];
		pre_p[1]=cur_p[1];

		if(type==0)
		{
			cur_p[0]+=quadmesh->xinterval*linedir.entry[0];
			cur_p[1]+=quadmesh->xinterval*linedir.entry[1];
		}
		else
		{
			/*we may try the other way to guide the tracing*/
		}

		/*judge whether it reaches the boundary or not*/
		//if(fabs(cur_p[0]-quadmesh->xstart)<1.e-6
		//	||fabs(cur_p[0]-quadmesh->xend)<1.e-6
		//	||fabs(cur_p[1]-quadmesh->ystart)<1.e-6
		//	||fabs(cur_p[1]-quadmesh->yend)<1.e-6)
		if(cur_p[0]<=quadmesh->xstart+1.e-8
			||cur_p[0]>=quadmesh->xend-1.e-8
			||cur_p[1]<=quadmesh->ystart+1.e-8
			||cur_p[1]>=quadmesh->yend-1.e-8)
		{
			/*compute the point on the boundary,
			  build a new line segment,
			  then, return
			*/
			
			//if(pre_p[0]<quadmesh->quadcells[cur_cell]->x_start_coord
			//	||pre_p[1]<quadmesh->quadcells[cur_cell]->y_start_coord
			//	||cur_p[0]>quadmesh->quadcells[cur_cell]->x_start_coord+quadmesh->xinterval
			//	||cur_p[1]>quadmesh->quadcells[cur_cell]->y_start_coord+quadmesh->yinterval)
			//	return;

			if(cur_p[0]<=quadmesh->xstart+1.e-8) cur_p[0]=quadmesh->xstart;
			else if(cur_p[0]>=quadmesh->xend-1.e-8) cur_p[0]=quadmesh->xend;
			if(cur_p[1]<=quadmesh->ystart+1.e-8) cur_p[1]=quadmesh->ystart;
			else if(cur_p[1]>=quadmesh->yend-1.e-8) cur_p[1]=quadmesh->yend;

			traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
			traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
			line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
				traj->linesegs[traj->nlinesegs].gstart[0];
			line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
				traj->linesegs[traj->nlinesegs].gstart[1];
			traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			traj->nlinesegs++;
			return;

			//if(fabs(cur_p[0]-quadmesh->xstart)<1.e-8)
			//{
			//	traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			//	traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			//	traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			//	traj->linesegs[traj->nlinesegs].gend[0]=quadmesh->xstart;
			//	traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
			//	line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
			//		traj->linesegs[traj->nlinesegs].gstart[0];
			//	line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
			//		traj->linesegs[traj->nlinesegs].gstart[1];
			//	traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			//	traj->nlinesegs++;
			//	return;
			//}
			//else if(fabs(cur_p[0]-quadmesh->xend)<1.e-8)
			//{
			//	traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			//	traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			//	traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			//	traj->linesegs[traj->nlinesegs].gend[0]=quadmesh->xend;
			//	traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
			//	line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
			//		traj->linesegs[traj->nlinesegs].gstart[0];
			//	line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
			//		traj->linesegs[traj->nlinesegs].gstart[1];
			//	traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			//	traj->nlinesegs++;
			//	return;
			//}
			//else if(fabs(cur_p[0]-quadmesh->ystart)<1.e-8)
			//{
			//	traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			//	traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			//	traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			//	traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
			//	traj->linesegs[traj->nlinesegs].gend[1]=quadmesh->ystart;
			//	line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
			//		traj->linesegs[traj->nlinesegs].gstart[0];
			//	line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
			//		traj->linesegs[traj->nlinesegs].gstart[1];
			//	traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			//	traj->nlinesegs++;
			//	return;
			//}
			//else
			//{
			//	traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			//	traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			//	traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			//	traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
			//	traj->linesegs[traj->nlinesegs].gend[1]=quadmesh->yend;
			//	line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
			//		traj->linesegs[traj->nlinesegs].gstart[0];
			//	line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
			//		traj->linesegs[traj->nlinesegs].gstart[1];
			//	traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			//	traj->nlinesegs++;
			//	return;
			//}
		}

		if(cur_cell<0 || cur_cell>=quadmesh->nfaces)
			return;

		if(is_in_cell(cur_cell, cur_p[0], cur_p[1]))
		{
			/*add to the line segment list*/
			/*construct a new line segment here*/
			if(traj->nlinesegs>=traj->curMaxNumLinesegs)
			{
				traj->extend_line_segments(50);
			}
			traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
			traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
			line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
				traj->linesegs[traj->nlinesegs].gstart[0];
			line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
				traj->linesegs[traj->nlinesegs].gstart[1];
			traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			traj->nlinesegs++;
		}

		else
		{
			/*find the next cell the curve will enter*/
			
			/*we first store the major vectors of the vertices
			of current cell*/
			face = quadmesh->quadcells[cur_cell];
			for(i=0; i<4; i++)
				t_major[i]=quadmesh->quad_verts[face->verts[i]]->major;

			/*replace them with the line segment direction*/
			for(i=0; i<4; i++)
				//quadmesh->quad_verts[face->verts[i]]->major=linedir;
				quadmesh->quad_verts[face->verts[i]]->major=tenline_dir_global;

			int passvertornot = 0;
			double tp[2]={pre_p[0], pre_p[1]};
			get_next_cell_2(cur_cell, pre_p, cur_p, passvertornot, 0);

			if(cur_cell<0 || cur_cell>=quadmesh->nfaces)
			{
				//if(fabs(cur_p[0]-quadmesh->xstart)<1.e-6
				//	||fabs(cur_p[0]-quadmesh->xend)<1.e-6
				//	||fabs(cur_p[1]-quadmesh->ystart)<1.e-6
				//	||fabs(cur_p[1]-quadmesh->yend)<1.e-6)
				if(cur_p[0]<=quadmesh->xstart+1.e-8
					||cur_p[0]>=quadmesh->xend-1.e-8
					||cur_p[1]<=quadmesh->ystart+1.e-8
					||cur_p[1]>=quadmesh->yend-1.e-8)
				{
					/*compute the point on the boundary,
					build a new line segment,
					then, return
					*/
					if(cur_p[0]<=quadmesh->xstart+1.e-8) cur_p[0]=quadmesh->xstart;
					else if(cur_p[0]>=quadmesh->xend-1.e-8) cur_p[0]=quadmesh->xend;
					if(cur_p[1]<=quadmesh->ystart+1.e-8) cur_p[1]=quadmesh->ystart;
					else if(cur_p[1]>=quadmesh->yend-1.e-8) cur_p[1]=quadmesh->yend;

					traj->linesegs[traj->nlinesegs].Triangle_ID=
						traj->linesegs[traj->nlinesegs-1].Triangle_ID;
					traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
					traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
					traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
					traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
					line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
						traj->linesegs[traj->nlinesegs].gstart[0];
					line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
						traj->linesegs[traj->nlinesegs].gstart[1];
					traj->linesegs[traj->nlinesegs].length=length(line_dir2);
					traj->nlinesegs++;
				}
				return;
			}

			if(passvertornot>0)
			{
				cur_p[0]=pre_p[0];
				cur_p[1]=pre_p[1];
				pre_p[0]=tp[0];
				pre_p[1]=tp[1];
			}

			/*we need to add one more line segment here*/
			if(traj->nlinesegs>=traj->curMaxNumLinesegs)
			{
				traj->extend_line_segments(50);
			}
			traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
			traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
			line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
				traj->linesegs[traj->nlinesegs].gstart[0];
			line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
				traj->linesegs[traj->nlinesegs].gstart[1];
			traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			traj->nlinesegs++;

			//linedir.set((cur_p[0]-pre_p[0]),(cur_p[1]-pre_p[1]));
			//normalize(linedir);

			/*store back the original vectors*/
			for(i=0; i<4; i++)
				quadmesh->quad_verts[face->verts[i]]->major=t_major[i];
		}
	}

	if(cur_cell<0 || cur_cell>=quadmesh->nfaces)
		return;

	/*add one more line segment*/
	if(traj->nlinesegs>=traj->curMaxNumLinesegs)
	{
		traj->extend_line_segments(5);
	}

	/*we need to find the intersection with *the other* sketch curve */
	int j;
	/*we use the first line to compute the intersection*/
	LinesInOneCell *firstline=quadmesh->quadcells[cur_cell]->sketchlines->lines[0];
	int startid=firstline->start;
	int endid=firstline->end;
	Trajectory *theother=sketchlines->trajs[firstline->whichtraj];
	j=(int)((startid+endid)/2);
	double appro_intersect[2];
	appro_intersect[0]=(theother->linesegs[j].gstart[0]+theother->linesegs[j].gend[0])/2;
	appro_intersect[1]=(theother->linesegs[j].gstart[1]+theother->linesegs[j].gend[1])/2;

	traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
	traj->linesegs[traj->nlinesegs].gstart[0]=cur_p[0];
	traj->linesegs[traj->nlinesegs].gstart[1]=cur_p[1];
	traj->linesegs[traj->nlinesegs].gend[0]=appro_intersect[0];
	traj->linesegs[traj->nlinesegs].gend[1]=appro_intersect[1];
	line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
		traj->linesegs[traj->nlinesegs].gstart[0];
	line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
		traj->linesegs[traj->nlinesegs].gstart[1];
	traj->linesegs[traj->nlinesegs].length=length(line_dir2);
	traj->nlinesegs++;
}


/*
        Compute the blocks determined by the highway network
*/

//void cal_blocks_sketchnet()
//{
//}
//

/***************************************************************************************/
/*            More general routines for finding all the blocks             */

/*
This routine initializes all the edges in the street graph
*/

RegionBlockList *sketchblocklist=NULL;

void init_sketchblocklist()
{
	if(sketchblocklist!=NULL)
		delete sketchblocklist;
	sketchblocklist=new RegionBlockList();
}

void init_all_network_edges(StreetNet *net)
{
	int i;
	StreetGraphEdge *cur_sedge;
	if(net==NULL) return;
	for(i=0; i<net->edgelist->nedges;i++)
	{
		cur_sedge=net->edgelist->edges[i];
		cur_sedge->nregionblocks=0;
	}
}

bool select_a_valid_edge(int nodeid, icVector2 normal, 
						 int &nextedge, int exceptedge, StreetNet *net)
{
	Intersection *pnode=net->nodelist->intersects[nodeid];
	StreetGraphEdge *cur_e;
	double sim=-50.;
	icVector2 line_dir;
	int i;
	nextedge=-1;

	if(pnode->nadjedges==2)
	{
		for(i=0;i<pnode->nadjedges;i++)
		{
			cur_e=net->edgelist->edges[pnode->adj_edges[i]];
			if(pnode->adj_edges[i]==exceptedge)
				continue;
			if(net->nodelist->intersects[cur_e->node_index1]->endpt
				||net->nodelist->intersects[cur_e->node_index2]->endpt)
				continue;
			if(cur_e->nregionblocks==2)
				continue;

			nextedge=pnode->adj_edges[i];
			return true;
		}

		return false;
	}

	for(i=0;i<pnode->nadjedges;i++)
	{
		if(pnode->adj_edges[i]==exceptedge)
			continue;

		cur_e=net->edgelist->edges[pnode->adj_edges[i]];

		if(cur_e->nregionblocks==2)
			continue;

		/*we don't consider danggling edge here as well*/
		if(net->nodelist->intersects[cur_e->node_index1]->endpt
			||net->nodelist->intersects[cur_e->node_index2]->endpt)
			continue;

		if(cur_e->node_index1==nodeid)
		{
			line_dir.entry[0]=net->nodelist->intersects[cur_e->node_index2]->gpos[0]
				-net->nodelist->intersects[cur_e->node_index1]->gpos[0];
			line_dir.entry[1]=net->nodelist->intersects[cur_e->node_index2]->gpos[1]
				-net->nodelist->intersects[cur_e->node_index1]->gpos[1];
		}
		else
		{
			line_dir.entry[0]=net->nodelist->intersects[cur_e->node_index1]->gpos[0]
				-net->nodelist->intersects[cur_e->node_index2]->gpos[0];
			line_dir.entry[1]=net->nodelist->intersects[cur_e->node_index1]->gpos[1]
				-net->nodelist->intersects[cur_e->node_index2]->gpos[1];
		}

		normalize(line_dir);

		double temp=dot(line_dir, normal);
		if(temp>sim)
		{
			sim=temp;
			nextedge=pnode->adj_edges[i];
		}
	}

	if(nextedge==-1)
		return false;
	else
		return true;
}


bool select_a_valid_edge_anglebased(int nodeid, icVector2 curdir, 
									int &nextedge, int exceptedge, StreetNet *net)
{
	Intersection *pnode=net->nodelist->intersects[nodeid];
	StreetGraphEdge *cur_e;
	double smallest_ag=50.;
	icVector2 line_dir;
	int i;
	nextedge=-1;

	curdir=-curdir;
	double ag1=atan2(curdir.entry[1], curdir.entry[0]);
	if(ag1<0) ag1+=2*M_PI;
	double ag2, ag_diff;

	if(pnode->nadjedges==2)
	{
		for(i=0;i<pnode->nadjedges;i++)
		{
			cur_e=net->edgelist->edges[pnode->adj_edges[i]];
			if(pnode->adj_edges[i]==exceptedge)
				continue;
			if(net->nodelist->intersects[cur_e->node_index1]->endpt
				||net->nodelist->intersects[cur_e->node_index2]->endpt)
				continue;
			if(cur_e->nregionblocks==2)
				continue;

			nextedge=pnode->adj_edges[i];
			return true;
		}

		return false;
	}

	for(i=0;i<pnode->nadjedges;i++)
	{
		if(pnode->adj_edges[i]==exceptedge)
			continue;

		cur_e=net->edgelist->edges[pnode->adj_edges[i]];

		if(cur_e->nregionblocks==2)
			continue;

		/*we don't consider danggling edge here as well*/
		if(net->nodelist->intersects[cur_e->node_index1]->endpt
			||net->nodelist->intersects[cur_e->node_index2]->endpt)
			continue;

		if(cur_e->node_index1==nodeid)
		{
			line_dir.entry[0]=net->nodelist->intersects[cur_e->node_index2]->gpos[0]
				-net->nodelist->intersects[cur_e->node_index1]->gpos[0];
			line_dir.entry[1]=net->nodelist->intersects[cur_e->node_index2]->gpos[1]
				-net->nodelist->intersects[cur_e->node_index1]->gpos[1];
		}
		else
		{
			line_dir.entry[0]=net->nodelist->intersects[cur_e->node_index1]->gpos[0]
				-net->nodelist->intersects[cur_e->node_index2]->gpos[0];
			line_dir.entry[1]=net->nodelist->intersects[cur_e->node_index1]->gpos[1]
				-net->nodelist->intersects[cur_e->node_index2]->gpos[1];
		}

		//normalize(line_dir);
		ag2=atan2(line_dir.entry[1], line_dir.entry[0]);
		if(ag2<0) ag2+=2*M_PI;

		ag_diff=ag1-ag2;
		if( ag_diff < -M_PI)
			ag_diff += 2 * M_PI;
		
		//if( ag_diff > M_PI)
		//	ag_diff -= 2 * M_PI;

		if(ag_diff>0&&ag_diff<smallest_ag)
		{
			smallest_ag=ag_diff;
			nextedge=pnode->adj_edges[i];
		}
	}

	if(nextedge==-1)
		return false;
	else
		return true;
}


/*
After obtaining the lists of edges and nodes that form a region block,
we call the following routine to store them into the corresponding data structure
*/
void construct_a_regionblock(int *nodes, int nnodes, int *edges, int nedges,
							 StreetNet *net, RegionBlockList *aregionblocklist)
{
	int i;

	/*create a new block*/
	RegionBlock *block=(RegionBlock*)malloc(sizeof(RegionBlock));
	block->edgelist=(int *)malloc(sizeof(int)*nedges);
	block->nodelist=(int *)malloc(sizeof(int)*nnodes);

	for(i=0; i<nnodes; i++)
	{
		block->nodelist[i]=nodes[i];
	}
	block->num_nodes=nnodes;

	for(i=0; i<nedges; i++)
	{
		block->edgelist[i]=edges[i];
		net->edgelist->edges[edges[i]]->regionblocks[
			net->edgelist->edges[edges[i]]->nregionblocks]=aregionblocklist->nelems;
		net->edgelist->edges[edges[i]]->nregionblocks++;
	}
	block->num_edges=nedges;

	block->closed_curved=false;
	block->trajid=-1;

	/*add to the block list*/
	aregionblocklist->append(block);
}



/*
search a block from current input edge based on the specified orientation
orient: false--follow the edge direction;  true--follow the inverse edge direction
*/
bool form_a_block(int edgeid, bool orient, StreetNet *net, 
				  RegionBlockList *aregionblocklist)
{
	StreetGraphEdge *start_sedge= net->edgelist->edges[edgeid];
	StreetGraphEdge *cur_sedge=start_sedge;
	int startnode, endnode, cur_node;
	Intersection *pendnode, *pcur_node;
	icVector2 line_dir;
	icVector2 cur_normal;
	int next_edge;

	int curMaxSelectedEdge=10;
	int *sel_edges=(int*)malloc(sizeof(int)*curMaxSelectedEdge);
	int *sel_nodes=(int*)malloc(sizeof(int)*curMaxSelectedEdge);
	sel_edges[0]=edgeid;
	int nsel_edges=1;

	
	if(!orient) /*it is following the edge direction*/
	{
		endnode=start_sedge->node_index1;
		startnode=cur_node=start_sedge->node_index2;
		sel_nodes[0]=cur_node;
	}

	else /*following the inverse edge direction*/
	{
		endnode=start_sedge->node_index2;
		startnode=cur_node=start_sedge->node_index1;
		sel_nodes[0]=cur_node;
	}

	pendnode=net->nodelist->intersects[endnode];
	pcur_node=net->nodelist->intersects[cur_node];
	line_dir.entry[0]=pcur_node->gpos[0]-pendnode->gpos[0];
	line_dir.entry[1]=pcur_node->gpos[1]-pendnode->gpos[1];
	/*obtain the inner normal*/
	cur_normal.entry[0]=-line_dir.entry[1];
	cur_normal.entry[1]=line_dir.entry[0];
	normalize(cur_normal);

	int cur_edgeid=edgeid;

	while(1)
	{
		//if(!select_a_valid_edge(cur_node, cur_normal, next_edge, cur_edgeid, net))
		if(!select_a_valid_edge_anglebased(cur_node, line_dir, next_edge, cur_edgeid, net))
		/*if we run out of all the choices*/
		{
			free(sel_edges);
			free(sel_nodes);
			return false;
		}

		cur_edgeid=next_edge;
		
		/*add the next_edge to the sel_edges list*/
		if(nsel_edges>=curMaxSelectedEdge)
		{
			sel_edges=(int*)realloc(sel_edges, sizeof(int)*(curMaxSelectedEdge+10));
			sel_nodes=(int*)realloc(sel_nodes, sizeof(int)*(curMaxSelectedEdge+10));
			curMaxSelectedEdge+=10;
		}

		if(is_repeated_elem(sel_edges, next_edge, nsel_edges))
		{
			free(sel_edges);
			free(sel_nodes);
			return false;
		}

		sel_edges[nsel_edges]=next_edge;
		nsel_edges++;

		/*update the normal*/
		/*find the next node to continue on*/
		cur_sedge=net->edgelist->edges[next_edge];
		pcur_node=net->nodelist->intersects[cur_node];
		if(cur_node==cur_sedge->node_index1) /*we should follow the edge direction*/
		{
			pendnode=net->nodelist->intersects[cur_sedge->node_index2];
			cur_sedge->inversed_orient=false;
			cur_node=cur_sedge->node_index2;
		}
		else if(cur_node==cur_sedge->node_index2)
		{
			pendnode=net->nodelist->intersects[cur_sedge->node_index1];
			cur_sedge->inversed_orient=true;
			cur_node=cur_sedge->node_index1;
		}
		else
			return false;

		sel_nodes[nsel_edges-1]=cur_node;

		if(cur_node==endnode) /*we find a block*/
		{
			/*construct a new block*/
			construct_a_regionblock(sel_nodes, nsel_edges, sel_edges, nsel_edges,
				net, aregionblocklist);

			free(sel_edges);
			free(sel_nodes);
			return true;
		}

		line_dir.entry[0]=pendnode->gpos[0]-pcur_node->gpos[0];
		line_dir.entry[1]=pendnode->gpos[1]-pcur_node->gpos[1];

		cur_normal.entry[0]=-line_dir.entry[1];
		cur_normal.entry[1]=line_dir.entry[0];

		normalize(cur_normal);
	}
}

				  
/*
construct block(s) for an input edge
Return: 1 block if the edge has become one edge of an existing block
        2 blocks if the edge has never be included by existing block
		0 block if this is an daggling edge
*/

int construct_blocks_for_an_edge(int edgeid, StreetNet *net, RegionBlockList *aregionblocklist)
{
	int obtained_blocks=0;

	StreetGraphEdge *cur_sedge=net->edgelist->edges[edgeid];

	if(cur_sedge->nregionblocks==0) /*never be included by existing block*/
	{
		cur_sedge=net->edgelist->edges[edgeid];
		cur_sedge->inversed_orient=false;
		if(form_a_block(edgeid, cur_sedge->inversed_orient, net, aregionblocklist))
			obtained_blocks++;

		cur_sedge->inversed_orient=true;
		if(form_a_block(edgeid, cur_sedge->inversed_orient, net, aregionblocklist))
			obtained_blocks++;
	}

	else if(cur_sedge->nregionblocks==1)/*has become one edge of an existing block*/
	{
		/*we need to figure out which orientation it has been used in that block*/
		cur_sedge=net->edgelist->edges[edgeid];
		cur_sedge->inversed_orient=!cur_sedge->inversed_orient;
		if(form_a_block(edgeid, cur_sedge->inversed_orient, net, aregionblocklist))
			obtained_blocks++;
		else
		{
			if(form_a_block(edgeid, !cur_sedge->inversed_orient, net, aregionblocklist))
				obtained_blocks++;
		}
	}

	return obtained_blocks;
}

/*
construct the regions by traversing the edge list
*/
void construct_regionblocks_edgewise(StreetNet *net, RegionBlockList *aregionblocklist)
{
	//aregionblocklist=init_regionblocklist_2(aregionblocklist);
	init_all_network_edges(net);
	int i;
	StreetGraphEdge *cur_sedge;

	for(i=0;i<net->edgelist->nedges;i++)
	{
		cur_sedge=net->edgelist->edges[i];
		if(cur_sedge->nregionblocks==2)
			continue;

		if(net->nodelist->intersects[cur_sedge->node_index1]->endpt
			||net->nodelist->intersects[cur_sedge->node_index2]->endpt)
			continue;

		//if it is a boundary edge, they belong to only one block region!!
		if((cur_sedge->node_index1==0||cur_sedge->node_index1==1
			||cur_sedge->node_index1==2||cur_sedge->node_index1==3
			||cur_sedge->node_index2==0 ||cur_sedge->node_index2==1
			||cur_sedge->node_index2==2 || cur_sedge->node_index2==3)
			&& cur_sedge->nregionblocks==1)
			continue;

		construct_blocks_for_an_edge(i, net, aregionblocklist);
	}

	/*****************************************************/
	//FILE *fp;
	//fp=fopen("lineseg_mem_error.txt", "w");
	//fprintf(fp, "constructing closed loop regions.\n");
	//fclose(fp);

	/*  consider the closed sketchlines 12/24/2007  */
	for(i=0;i<sketchlines->ntrajs;i++)
	{
		if(!sketchlines->trajs[i]->closed)
			continue;

		/*  assign a block for the inner of the region  */
		/*  NOTE:  currently, we handle convex region only  */

		RegionBlock *block=(RegionBlock*)malloc(sizeof(RegionBlock));
		if(block==NULL)
		{
			continue;
		}
		block->edgelist=(int *)malloc(sizeof(int));
		block->nodelist=(int *)malloc(sizeof(int));
		block->closed_curved=true;
		block->trajid=i;

		/*  use the first integrate point as the node  */
		block->nodelist[0]=-1;  /*  may be we should assign an new intersection in the graph for it:)  */
		block->num_nodes=0;

		block->edgelist[0]=-1;  /*  may be we should assign an new edge in the graph for it:)  */
		block->num_edges=0;

		/*add to the block list*/
		aregionblocklist->append(block);

		//fp=fopen("lineseg_mem_error.txt", "a");
		//fprintf(fp, "finish sketch %d out of %d.\n", i, sketchlines->ntrajs);
		//fclose(fp);
	}
}

#include <gl/glut.h> 

extern void getcolor_scc_frac(int num, int frac, float rgb[3]);

void vis_regionblocks(RegionBlockList *aregionblocklist, StreetNet *net)
{
	if(aregionblocklist==NULL) return;

	glDisable(GL_TEXTURE_2D);
	glDisable(GL_LIGHTING);
	
	//153 179 204 	
	glClear(GL_COLOR_BUFFER_BIT);
	glClearColor(0.6, .7, 0.9, 1.);

	int i, j;
	float rgb[3]={0.};
	Intersection *cur_n;
	for(i=0;i<aregionblocklist->nelems;i++)
	{
		//if(regionblocklist->blocks[i]->num_nodes>5)
		//	continue;

		getcolor_scc_frac(i, 9, rgb);
		glColor3fv(rgb);
		glBegin(GL_POLYGON);
		for(j=0;j<aregionblocklist->blocks[i]->num_nodes; j++)
		{
			cur_n=net->nodelist->intersects[aregionblocklist->blocks[i]->nodelist[j]];
			glVertex2f(cur_n->gpos[0], cur_n->gpos[1]);
		}
		glEnd();
	}

	/*visualize those edges having only one block sharing them*/
	StreetGraphEdge *cur_sedge;
	glLineWidth(3.);
	glColor3f(1,1,1);
	for(i=0;i<net->edgelist->nedges;i++)
	{
		cur_sedge=net->edgelist->edges[i];

		if(cur_sedge->nregionblocks<2)
		{
			Intersection *n1, *n2;
			n1=net->nodelist->intersects[cur_sedge->node_index1];
			n2=net->nodelist->intersects[cur_sedge->node_index2];
			glBegin(GL_LINES);
				glVertex2f(n1->gpos[0], n1->gpos[1]);
				glVertex2f(n2->gpos[0], n2->gpos[1]);
			glEnd();
		}

	}
	glLineWidth(1.);
}

#include "bmpProcess.h"
#include "ppm.h"


void render_a_polygon(int sketchid, int numregs)
{
	Trajectory *curtraj=sketchlines->trajs[sketchid];
	int i;
	unsigned char uniquecolor;

	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	glEnable(GL_STENCIL_TEST);						// Enable Stencil Buffer For "marking" The Floor
	glStencilFunc(GL_ALWAYS, 1, 1);						// Always Passes, 1 Bit Plane, 1 As Mask
	glStencilOp(GL_INVERT, GL_INVERT, GL_INVERT);	// We Set The Stencil Buffer To 1 Where We Draw Any Polygon

	/*  first round, modify the stencil buffer  */
		
	glBegin(GL_TRIANGLE_FAN);
	glVertex2f(curtraj->linesegs[0].gstart[0], curtraj->linesegs[0].gstart[1]);
	for(i=1;i<curtraj->nlinesegs;i++)
	{
		glVertex2f(curtraj->linesegs[i].gstart[0], curtraj->linesegs[i].gstart[1]);
		glVertex2f(curtraj->linesegs[i].gend[0], curtraj->linesegs[i].gend[1]);
	}
	glEnd();

	/*  second round, draw the polygon according to the stencil buffer  */
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	glStencilFunc(GL_EQUAL, 1, 1);
	glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);	

	uniquecolor=(unsigned char)((255/numregs)*sketchid);
	glColor4ub(uniquecolor,uniquecolor,uniquecolor,122);

	glBegin(GL_TRIANGLE_FAN);
	glVertex2f(curtraj->linesegs[0].gstart[0], curtraj->linesegs[0].gstart[1]);
	for(i=1;i<curtraj->nlinesegs;i++)
	{
		glVertex2f(curtraj->linesegs[i].gstart[0], curtraj->linesegs[i].gstart[1]);
		glVertex2f(curtraj->linesegs[i].gend[0], curtraj->linesegs[i].gend[1]);
	}
	glEnd();


	glDisable(GL_STENCIL_TEST);
}


/*
        After obtaining the region blocks, we assign unique color for 
		each subregion
*/

void color_subregionblocks(RegionBlockList *aregionblocklist, StreetNet *net)
{
	if(aregionblocklist==NULL) return;

	glDisable(GL_TEXTURE_2D);
	glDisable(GL_LIGHTING);
	
	//153 179 204 	
	//glClear(GL_COLOR_BUFFER_BIT);
	glClearColor(1, 1, 1, 1.);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	int viewport[4] = {0};

	glGetIntegerv(GL_VIEWPORT, viewport);

	int dx = viewport[2] - viewport[0];
	int dy = viewport[3] - viewport[1];

	unsigned char *colored_region_temp = 
		(unsigned char *)malloc(sizeof(unsigned char)*(3*dx*dy));

	FILE *fp;

	int i, j;
	unsigned char uniquecolor;

	/**/
	int k;
	RegionBlock *curblock;
	StreetGraphEdge *cur_edge;

	/*  for the closed loop   */
	int nclosedloops=0;
	int cur_reg_id=0;
	for(i=0;i<sketchlines->ntrajs;i++)
	{
		if(!sketchlines->trajs[i]->closed)
			continue;
		nclosedloops++;
	}

	//glEnable(GL_BLEND);

	for(i=0;i<aregionblocklist->nelems;i++)
	{

	//fp=fopen("lineseg_mem_error.txt", "w");
	//fprintf(fp, "render region %d out of %d.\n", i, aregionblocklist->nelems);
	//fclose(fp);

		uniquecolor=(unsigned char)((255./(aregionblocklist->nelems+nclosedloops))*i);
		glColor3ub(uniquecolor,uniquecolor,uniquecolor);
		//glColor4ub(uniquecolor,uniquecolor,uniquecolor, 122);

		curblock=aregionblocklist->blocks[i];

		if(!curblock->closed_curved)
		{
			//glBegin(GL_POLYGON);
			glBegin(GL_TRIANGLE_FAN);
			for(j=0;j<curblock->num_nodes; j++)
			{
				if(curblock->edgelist[j]<0)
					continue;

				cur_edge=sketchnet->edgelist->edges[curblock->edgelist[j]];
				if(curblock->nodelist[j]==cur_edge->node_index2)
				{
					for(k=0;k<cur_edge->ninter_pts;k++)
					{
						glVertex2f(cur_edge->inter_pts[k]->x, 
							cur_edge->inter_pts[k]->y);
					}
				}
				else
				{
					for(k=cur_edge->ninter_pts-1;k>=0;k--)
					{
						glVertex2f(cur_edge->inter_pts[k]->x, 
							cur_edge->inter_pts[k]->y);
					}
				}
			}
			glEnd();
		}
		else
		{
	//fp=fopen("lineseg_mem_error.txt", "w");
	//fprintf(fp, "render a closed curve.\n");
	//fclose(fp);

			Trajectory *curtraj=sketchlines->trajs[curblock->trajid];
			//glColor4ub(uniquecolor,uniquecolor,uniquecolor, 122);

			glBegin(GL_TRIANGLE_FAN);
			//glVertex2f(curtraj->linesegs[0].gstart[0], curtraj->linesegs[0].gstart[1]);
			for(j=0;j<curtraj->nlinesegs-1;j++)
			{
				glVertex2f(curtraj->linesegs[j].gstart[0], curtraj->linesegs[j].gstart[1]);
				glVertex2f(curtraj->linesegs[j+1].gstart[0], curtraj->linesegs[j+1].gstart[1]);
			}
			glEnd();
			//render_a_polygon(curblock->trajid, (aregionblocklist->nelems+nclosedloops));
		}
	}

	/* Remarks (12/25/2007):  
	   It is still possible to use color blending and image processing algorithm to assign the correct
	   region index to the specific region.
	   First, we need to fix the problem of Stencil buffer
	*/

	//glDisable(GL_BLEND);

	/*  possible bug exists  */
	/*  for the closed loop, we only need to show those loop without intersections!!!!   */

	////glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	////glEnable(GL_STENCIL_TEST);						// Enable Stencil Buffer For "marking" The Floor
	////glStencilFunc(GL_ALWAYS, 1, 1);						// Always Passes, 1 Bit Plane, 1 As Mask
	////glStencilOp(GL_INVERT, GL_KEEP, GL_INVERT);	// We Set The Stencil Buffer To 1 Where We Draw Any Polygon

	/////*  first round, modify the stencil buffer  */
	////for(i=0;i<sketchlines->ntrajs;i++)
	////{
	////	if(!sketchlines->trajs[i]->closed)
	////		continue;
	////	
	////	Trajectory *curtraj=sketchlines->trajs[j];
	////	glBegin(GL_TRIANGLE_FAN);
	////	glVertex2f(curtraj->linesegs[0].gstart[0], curtraj->linesegs[0].gstart[1]);
	////	for(j=1;j<curtraj->nlinesegs-1;j++)
	////	{
	////		glVertex2f(curtraj->linesegs[j].gstart[0], curtraj->linesegs[j].gstart[1]);
	////		glVertex2f(curtraj->linesegs[j+1].gstart[0], curtraj->linesegs[j+1].gstart[1]);
	////	}
	////	glEnd();
	////}

	/////*  second round, draw the polygon according to the stencil buffer  */
	////glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	////glStencilFunc(GL_EQUAL, 1, 1);
	////glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);	
	//cur_reg_id=aregionblocklist->nelems;
	//for(i=0;i<sketchlines->ntrajs;i++)
	//{
	//	if(!sketchlines->trajs[i]->closed)
	//		continue;

	//	uniquecolor=(unsigned char)((255/(aregionblocklist->nelems+nclosedloops))*cur_reg_id);
	//	glColor3ub(uniquecolor,uniquecolor,uniquecolor);

	//	Trajectory *curtraj=sketchlines->trajs[i];
	//	//glBegin(GL_POLYGON);
	//	//for(j=0;j<curtraj->nlinesegs;j++)
	//	//{
	//	//	glVertex2f(curtraj->linesegs[j].gstart[0], curtraj->linesegs[j].gstart[1]);
	//	//}
	//	//glEnd();

	//	glBegin(GL_TRIANGLE_FAN);
	//	glVertex2f(curtraj->linesegs[0].gstart[0], curtraj->linesegs[0].gstart[1]);
	//	for(j=1;j<curtraj->nlinesegs-1;j++)
	//	{
	//		glVertex2f(curtraj->linesegs[j].gstart[0], curtraj->linesegs[j].gstart[1]);
	//		glVertex2f(curtraj->linesegs[j+1].gstart[0], curtraj->linesegs[j+1].gstart[1]);
	//	}
	//	glEnd();

	//	cur_reg_id++;
	//}

	//glDisable(GL_STENCIL_TEST);

	//fp=fopen("lineseg_mem_error.txt", "w");
	//fprintf(fp, "start saving to .ppm file\n");
	//fclose(fp);


	if(coloredregion!=NULL)
		free(coloredregion);

	coloredregion = (unsigned char *)malloc(sizeof(unsigned char)*(3*dx*dy));
	if( coloredregion == NULL )
	{
		free(colored_region_temp);
		return;
	}


	/* setup and do the dump:					*/

	glPixelStorei( GL_PACK_ALIGNMENT, 4 );
	//glPixelStorei( GL_PACK_ROW_LENGTH, dx );
	glReadBuffer( GL_BACK );
	glReadPixels( 0, 0, dx, dy, GL_RGB, GL_UNSIGNED_BYTE, coloredregion );


	SSS_SavePPM(dx,dy, coloredregion, "test_output.ppm");
	
	/*		we then classify the vertices of the mesh into different region 
			according to the colors they are assigned
	*/
	double xinterval=(quadmesh->xend-quadmesh->xstart)/(dx-1);
	double yinterval=(quadmesh->yend-quadmesh->ystart)/(dy-1);

	cur_max_reg_index=0;
	
	for(i=0; i<quadmesh->nverts; i++)
	{
		int c=(quadmesh->quad_verts[i]->x-quadmesh->xstart)/xinterval;
		int r=(quadmesh->quad_verts[i]->y-quadmesh->ystart)/yinterval;

		int id=(r*(dx)+c);
		if(c>=dx) c=dx-1;
		if(r>=dy) r=dy-1;

		/*  !!!! we may make use of more intelligent function here 11/25/2007 */

		//quadmesh->quad_verts[i]->which_region=
		//	(int)((double)coloredregion[3*id]/255.*(aregionblocklist->nelems+1));

		/*  we let the region indexes are greater than 0 to avoid the global
		    effect of the first design element
		*/
		quadmesh->quad_verts[i]->which_region=
			(int)((double)coloredregion[3*id]/255.*(aregionblocklist->nelems+nclosedloops+1))+1;

		//quadmesh->quad_verts[i]->which_region=
		//	(int)coloredregion[3*id];

		if(quadmesh->quad_verts[i]->which_region>cur_max_reg_index)
			cur_max_reg_index=quadmesh->quad_verts[i]->which_region;
	}
	
	/*mark the cells*/
	for(i=0;i<quadmesh->nfaces;i++)
		quadmesh->quadcells[i]->which_region=get_region_id_for_cell(i);

	free(coloredregion);
	coloredregion=NULL;
	free(colored_region_temp);
	
	//fp=fopen("lineseg_mem_error.txt", "w");
	//fprintf(fp, "finish\n");
	//fclose(fp);
}



void store_sketchline_to_majandmin()
{
	int i;
	init_evenplace_ten();
	
	/*  copy to the major lines  */
	for(i=0;i<sketchlines->ntrajs;i++)
	{
		major->evenstreamlines->trajs[i]->add_front_nlines(sketchlines->trajs[i]->linesegs,
			sketchlines->trajs[i]->nlinesegs);

		/*we need to sample it, this can be done before tracing 
		  in the placestreamlines routine
		*/

		int cur_line = 0;
		double cur_length = major->evenstreamlines->trajs[i]->linesegs[0].length;
		major->samplepts[i]->samples[0]->gpt[0] = major->evenstreamlines->trajs[i]->linesegs[0].gstart[0];
		major->samplepts[i]->samples[0]->gpt[1] = major->evenstreamlines->trajs[i]->linesegs[0].gstart[1];
		major->samplepts[i]->samples[0]->triangle = major->evenstreamlines->trajs[i]->linesegs[0].Triangle_ID;
		major->samplepts[i]->nsamples = 1;

		int movetonext = 0;
		double sample_interval;
	    major->cal_samplepts_when_tracing(i, sample_interval, cur_line, movetonext, cur_length,
			major->samplepts[i]->samples, major->samplepts[i]->nsamples);
	}

	/*  copy to the minor lines  */
	for(i=0;i<sketchlines->ntrajs;i++)
	{
		minor->evenstreamlines->trajs[i]->add_front_nlines(sketchlines->trajs[i]->linesegs,
			sketchlines->trajs[i]->nlinesegs);
	}

	/*    set a flag to let the placer know that the highway network 
		  has been specified
	*/
}



/*
	Sample the specified portion of a tensor line (start_lineseg, end_lineseg),
	using desired sample rate. Return is a list of sampled points.
*/

void resample_along_tensorline_from_to(Trajectory *traj, int start_lineseg, double startp[2],
									 int end_lineseg, double endp[2], 
									 double sample_rate, SamplePt **pts, int &nsamps)
{
	int i;
	//if(pts==NULL)
	//{
	//	curMaxSampNum=100;
	//	pts=(SamplePt **)malloc(sizeof(SamplePt*)*curMaxSampNum);
	//	for(i=0;i<curMaxSampNum;i++)
	//	{
	//		pts[i]=NULL;
	//	}
	//}

}


void add_to_edgelist_one_cell(int cellid, int edgeid)
{
	if(quadmesh->quadcells[cellid]->streetgraphedgelist==NULL)
		quadmesh->quadcells[cellid]->streetgraphedgelist
		=(int*)malloc(sizeof(int));
	else
	{
		quadmesh->quadcells[cellid]->streetgraphedgelist=
			extend_link(quadmesh->quadcells[cellid]->streetgraphedgelist,
			quadmesh->quadcells[cellid]->nstreetgraphedges);
	}
	quadmesh->quadcells[cellid]->streetgraphedgelist[
		quadmesh->quadcells[cellid]->nstreetgraphedges]=edgeid;
		quadmesh->quadcells[cellid]->nstreetgraphedges++;

}

/*
	Sample the specified portion of a tensor line (start_lineseg, end_lineseg),
	using the original line segment. Return is a list of sampled points.
*/

void sample_along_tensorline_from_to(Trajectory *traj, int start_lineseg, double startp[2],
									 int end_lineseg, double endp[2], 
									 int edgeid, StreetNet *net)
{
	/*sample the line segments between the two intersections*/

	int i;
	StreetGraphEdge *edge = net->edgelist->edges[edgeid];

	Point *newpt=(Point*)malloc(sizeof(Point));
	newpt->x=startp[0];
	newpt->y=startp[1];
	//newpt->cellid=traj->linesegs[start_lineseg].Triangle_ID;
	newpt->cellid=get_cellID_givencoords(startp[0], startp[1]);

	if(edge->inter_pts==NULL || edge->ninter_pts==0)
	{
		edge->inter_pts = (Point**)malloc(sizeof(Point*));
	}
	edge->inter_pts[0]=newpt;
	edge->ninter_pts=1;

	int pre_cell=-1;
	
	for(i=start_lineseg+1;i<=end_lineseg; i++)
	{
		Point *newpti=(Point*)malloc(sizeof(Point));
		newpti->x=traj->linesegs[i].gstart[0];
		newpti->y=traj->linesegs[i].gstart[1];
		newpti->cellid=traj->linesegs[i].Triangle_ID;
		edge->inter_pts=(Point**)realloc(edge->inter_pts, sizeof(Point*)*(edge->ninter_pts+1));
		edge->inter_pts[edge->ninter_pts]=newpti;
		edge->ninter_pts++;

		/*   update the edge list of the cells it passes  12/15/2007    */
		if(pre_cell != newpti->cellid)
		{
			/*   add to the cell edge list   */
			add_to_edgelist_one_cell(newpti->cellid, edgeid);
			pre_cell=newpti->cellid;
		}

	}

	/*deal with the last line segment*/
	Point *newptn=(Point*)malloc(sizeof(Point));
	newptn->x=endp[0];
	newptn->y=endp[1];
	newptn->cellid=get_cellID_givencoords(endp[0], endp[1]);

	edge->inter_pts=(Point**)realloc(edge->inter_pts, sizeof(Point*)*(edge->ninter_pts+1));
	edge->inter_pts[edge->ninter_pts]=newptn;

	edge->ninter_pts++;

	if(newptn->cellid!=pre_cell)
		add_to_edgelist_one_cell(newptn->cellid, edgeid);
}


/*
	Sample the specified portion of a tensor line following the reversed orientation,
	Typically for the last line segments of a closed tensor line
*/

//void sample_along_tensorline_from_to_closed(Trajectory *traj, int start_lineseg, double startp[2],
//									 int end_lineseg, double endp[2], 
//									 int edgeid, StreetNet *net)
//{
//	/*sample the line segments between the two intersections*/
//
//	int i;
//	StreetGraphEdge *edge = net->edgelist->edges[edgeid];
//
//	Point *newpt=(Point*)malloc(sizeof(Point));
//	newpt->x=startp[0];
//	newpt->y=startp[1];
//	//newpt->cellid=traj->linesegs[start_lineseg].Triangle_ID;
//	newpt->cellid=get_cellID_givencoords(startp[0], startp[1]);
//
//	if(edge->inter_pts==NULL || edge->ninter_pts==0)
//	{
//		edge->inter_pts = (Point**)malloc(sizeof(Point*));
//	}
//	edge->inter_pts[0]=newpt;
//	edge->ninter_pts=1;
//
//	int pre_cell=-1;
//	
//	for(i=start_lineseg+1;i<=end_lineseg; i++)
//	{
//		Point *newpti=(Point*)malloc(sizeof(Point));
//		newpti->x=traj->linesegs[i].gstart[0];
//		newpti->y=traj->linesegs[i].gstart[1];
//		newpti->cellid=traj->linesegs[i].Triangle_ID;
//		edge->inter_pts=(Point**)realloc(edge->inter_pts, sizeof(Point*)*(edge->ninter_pts+1));
//		edge->inter_pts[edge->ninter_pts]=newpti;
//		edge->ninter_pts++;
//
//		/*   update the edge list of the cells it passes  12/15/2007    */
//		if(pre_cell != newpti->cellid)
//		{
//			/*   add to the cell edge list   */
//			add_to_edgelist_one_cell(newpti->cellid, edgeid);
//			pre_cell=newpti->cellid;
//		}
//
//	}
//
//	/*deal with the last line segment*/
//	Point *newptn=(Point*)malloc(sizeof(Point));
//	newptn->x=endp[0];
//	newptn->y=endp[1];
//	newptn->cellid=get_cellID_givencoords(endp[0], endp[1]);
//
//	edge->inter_pts=(Point**)realloc(edge->inter_pts, sizeof(Point*)*(edge->ninter_pts+1));
//	edge->inter_pts[edge->ninter_pts]=newptn;
//
//	edge->ninter_pts++;
//
//	if(newptn->cellid!=pre_cell)
//		add_to_edgelist_one_cell(newptn->cellid, edgeid);
//}
//
//
/****************************************************************************************/
/*          Generalize tensor field based on the user specified "Highway Network"       */

extern int *boundarycells;
extern int nboundarycells;
extern int *boundvertlist;
extern int nboundverts;

extern MinHeap *narrowband;

extern void init_quad_regionsmooth();

/*
      create a sequence of regular elements according to the sketch curves
	  and their orientation
*/
int get_sketchbased_approDir()
{
	int i,j;
	Trajectory *traj;

	int newadd_regElems=0;

	for(i=0;i<sketchlines->ntrajs;i++)
	{
		traj=sketchlines->trajs[i];
		for(j=0;j<traj->nlinesegs-1;j++)
		{
			set_ten_regBasis(traj->linesegs[j].gstart[0], traj->linesegs[j].gstart[1], 0);
			ten_regularelems[nten_regelems-1].which_region=0;
			set_ten_regDir(traj->linesegs[j+1].gstart[0], traj->linesegs[j+1].gstart[1]);
			newadd_regElems++;
		}
	}

	return newadd_regElems;
}



/*
*/
void cal_init_sketches_verts_onebrush(int which_traj)
{
	int i, j, k;
	int curve_pos=0;
	QuadCell *face;
	QuadVertex *v;
	double start[2], end[2];
	double distanceLine, disttoline;
	int pre_pos = 0;

	Trajectory *traj=sketchlines->trajs[which_traj];

	/*calculate the cell strip that contains the curve*/
	//init_dis_verts();
	init_dis_cells();

	//nboundarycells=0;

	/* copy the triangle id of each line segment to the boundary cell list */
	for(i=0;i<traj->nlinesegs;i++)
	//for(i=1;i<traj->nlinesegs-1;i++)
	{
		if(quadmesh->quadcells[traj->linesegs[i].Triangle_ID]->OnBoundary)
			continue;

		QuadCell *qc=quadmesh->quadcells[traj->linesegs[i].Triangle_ID];
		if(traj->linesegs[i].gstart[0]+1.e-6<qc->x_start_coord
			||traj->linesegs[i].gstart[1]+1.e-6<qc->y_start_coord
			||traj->linesegs[i].gend[0]-1.e-6>qc->x_start_coord+quadmesh->xinterval
			||traj->linesegs[i].gend[1]-1.e-6>qc->y_start_coord+quadmesh->yinterval)
			continue;

		boundarycells[nboundarycells]=traj->linesegs[i].Triangle_ID;
		nboundarycells++;

		quadmesh->quadcells[traj->linesegs[i].Triangle_ID]->OnBoundary=true;
	}

	/////////////////////
	//nboundverts=0;

	for(i=0; i<nboundarycells; i++)
	{
		face=quadmesh->quadcells[boundarycells[i]];

		for(j=0; j<face->nverts; j++)
			quadmesh->quad_verts[face->verts[j]]->visited=false;
	}

	int start_lineseg, end_lineseg;
	bool found=false;

	start_lineseg=end_lineseg=0;
	for(i=0; i<nboundarycells; i++)
	{
		face=quadmesh->quadcells[boundarycells[i]];

		/*  we first find out which linesegments will affect the calculation of
		    the distance from the sketch curve to the vertex
		*/
		found=false;
		for(j=0;j<traj->nlinesegs;j++)
		{
			if(boundarycells[i]==traj->linesegs[j].Triangle_ID)
			{
				if(!found)
				{
					found=true;
					start_lineseg=j;
				}
				else
				{
					end_lineseg=j;
				}
			}

			else if(found)
				break;
		}

		for(j=0; j<face->nverts; j++)
		{
			v=quadmesh->quad_verts[face->verts[j]];

			if(!v->visited)
			{
				boundvertlist[nboundverts]=v->index;
				nboundverts++;
			}
			v->visited=true;

			for(k=start_lineseg;k<end_lineseg;k++)
			{

				start[0]=traj->linesegs[k].gstart[0];
				start[1]=traj->linesegs[k].gstart[1];
				end[0]=traj->linesegs[k].gend[0];
				end[1]=traj->linesegs[k].gend[1];
				DistanceFromLine(v->x, v->y,
					start[0],start[1],  end[0],end[1],  distanceLine, disttoline);

				if(distanceLine<v->distance)
				{
					v->distance=distanceLine;
				}
			}

		}
	}

	/*propagate to certain distance to get the vertices on the front*/
	//cal_ten_with_fast_marching_quad(disthred, which_bound);
}



void cal_ten_with_fast_marching_sketchbased(double disthred)
{
	/*first, initialization*/
	/*since some vertices may contain the distance from other boundary*/
	/*11/17/2007*/
	reset_narrowband();

	init_narrow_band();

	///*second, loop as follows*/
	//	/*
	//	while (min-heap is not empty and no more far away points)
	//	{
	//		remove the root of the heap (with smallest distance value), 
	//		mark the corresponding vertex as "known";
	//		update the distance values of its neighbors if they are not "known",
	//		update the heap if they are "in the narrow band" with the new distance values;
	//		if any of them are not "in the narrow band" (i.e. "far away"), insert them to the heap and 
	//		mark them as "in the narrow band"
	//	}
	//	*/

	int nfinished = nboundverts;
	while(!narrowband->is_empty() && nfinished < quadmesh->nverts)
	{
		int cur_v = narrowband->FindSmallest();
		quadmesh->quad_verts[cur_v]->type = 2;

		/*we need to get the tensor on this vertex*/
		double t[4];

		//if(!sharedvars.UseAllBoundsOn)
		//{
		//	if(quadmesh->quad_verts[cur_v]->which_region>0)
		//	{
		//		/*we need to blend with previous tensor there*/
		//		get_tensor(quadmesh->quad_verts[cur_v]->x, quadmesh->quad_verts[cur_v]->y, t);
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[0][0]+=t[0];
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[0][1]+=t[1];
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[1][0]+=t[2];
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[1][1]+=t[3];
		//	}
		//	else
		//	{
		//		/*just compute the tensor there*/
		//		get_tensor(quadmesh->quad_verts[cur_v]->x, quadmesh->quad_verts[cur_v]->y, t);
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[0][0]=t[0];
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[0][1]=t[1];
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[1][0]=t[2];
		//		quadmesh->quad_verts[cur_v]->Jacobian.entry[1][1]=t[3];
		//	}
		//}
		//else
		//{
				get_tensor(quadmesh->quad_verts[cur_v]->x, quadmesh->quad_verts[cur_v]->y, t);
				quadmesh->quad_verts[cur_v]->Jacobian.entry[0][0]=t[0];
				quadmesh->quad_verts[cur_v]->Jacobian.entry[0][1]=t[1];
				quadmesh->quad_verts[cur_v]->Jacobian.entry[1][0]=t[2];
				quadmesh->quad_verts[cur_v]->Jacobian.entry[1][1]=t[3];

				//quadmesh->quad_verts[cur_v]->which_region=0;
		//}

		boundvertlist[nboundverts]=cur_v;
		nboundverts++;
		
		/*update neighbor distances of cur_v*/
		if(quadmesh->quad_verts[cur_v]->distance<disthred)
			update_neighbor_Dis(cur_v);

		nfinished ++;
	}


	/*  we set the brush affecting region as 0-indexed   */
	int i;
	for(i=0;i<nboundverts;i++)
	{
		//quadmesh->quad_verts[boundvertlist[i]]->which_region=0;
		quadmesh->quad_verts[boundvertlist[i]]->inbrushregion=true;
	}

	/*  update the region indexes of all the cells  */
	for(i=0;i<quadmesh->nfaces;i++)
		quadmesh->quadcells[i]->which_region=get_region_id_for_cell(i);
}



/*
     After combining with the previous design result, we need to relabel all
	 the existing design elements based on the new segmentation
*/
void reset_region_indexes_all_designElems()
{
	int i;
	/*reset the singular design elements*/
	for(i=0;i<ntenelems;i++)
		ten_designelems[i].which_region=
			get_region_id(ten_designelems[i].centerx, ten_designelems[i].centery);

	/*reset the regular design elements*/
	for(i=0;i<nten_regelems-gen_regElem_sketches;i++)
		ten_regularelems[i].which_region=
			get_region_id(ten_regularelems[i].base[0], ten_regularelems[i].base[1]);
}



/*
we borrow the idea of multiple boundary tensor field generation in the 
geograph-based tensor field generation

11/26/2007
*/
void gen_sketch_based_tensorfield(double widtheachbound)
{
	int i, j;

	/*initial all the vertices only once !!*/

	/*  if we want to combine with the previous result, we don't need to
	    reset it  12/03/2007
	*/
	//init_dis_verts(); 

	reset_region_indexes_all_designElems();	

	for(i=0;i<quadmesh->nverts;i++)
		quadmesh->quad_verts[i]->inbrushregion=false;
	init_quad_regionsmooth();

	/*set the regular elements using all the boundary information*/
	//if(sharedvars.UseAllBoundsOn)
	nten_regelems=max(0,nten_regelems-gen_regElem_sketches);
	gen_regElem_sketches=get_sketchbased_approDir();

	nboundverts = 0;
	nboundarycells=0;

	for(i=0;i<sketchlines->ntrajs;i++)
	{
		init_boundvertlist();

		cal_init_sketches_verts_onebrush(i);

		/*set the boundary orientation as the set of regular elements*/
		//if(!sharedvars.UseAllBoundsOn)
		//	get_imgbound_approRegElems_onebound(i);

		/*get the tensor values for each vertex inside the band with the user
		specified width*/
		//cal_ten_with_fast_marching_quad(widtheachbound, i);
	}

	int cur_v;
	double t[4]={0.};
	for(i=0;i<nboundverts;i++)
	{
		cur_v=boundvertlist[i];
		get_tensor(quadmesh->quad_verts[cur_v]->x, quadmesh->quad_verts[cur_v]->y, t);
		quadmesh->quad_verts[cur_v]->Jacobian.entry[0][0]=t[0];
		quadmesh->quad_verts[cur_v]->Jacobian.entry[0][1]=t[1];
		quadmesh->quad_verts[cur_v]->Jacobian.entry[1][0]=t[2];
		quadmesh->quad_verts[cur_v]->Jacobian.entry[1][1]=t[3];
	}

	cal_ten_with_fast_marching_sketchbased(widtheachbound);

	/*set up the sparse linear system*/
	//find_innerverts_multibounds();
	//smooth_Jac_quadregion();
	cal_all_eigenvecs_quad();

	//nten_regelems=0;
	//get_sketchbased_approDir();
}



/*
    save multiple brushes (sketch-based design) into a file
*/

void save_sketch_brushes(char *filename)
{
	int i, j;

	Brush *cur_brush;

	FILE *fp = fopen(filename, "w");

	if(fp==NULL)
		return;
	
	////write control points
	fprintf(fp, "#total brushes:%d\n", brushes->nbrushes);

	for(i = 0; i < brushes->nbrushes; i++)
	{
		cur_brush=&brushes->brushlist[i];
		fprintf(fp, "brush %d: %d\n", i, cur_brush->nelems);

		for(j=0;j<cur_brush->nelems;j++)
			fprintf(fp, "%f, %f, %d\n", cur_brush->brushpts[j]->x, cur_brush->brushpts[j]->y,
				cur_brush->brushpts[j]->cellid);
	}
	fclose(fp);
}


/*
     load the previously stored sketches from an input file
*/

bool load_sketch_brushes(char *filename)
{
	FILE *fp = fopen(filename, "r");

	if(fp==NULL)
		return false;

	int nbrushes;
	fscanf(fp, "#total brushes:%d\n", &nbrushes);

	if(nbrushes==0) return false;

	/*   reset the data structure to store the loaded brushes   */
	if(brushes!=NULL)
	{
		delete brushes;
		brushes=NULL;
	}

	init_brushlist();
	init_sketchnet();
	release_domain_boundaries();
	init_domain_boundaries();
	highwayexisted=false;
	gen_regElem_sketches=0;

	int i, j;
	float x, y;
	int cellid;
	for(i=0;i<nbrushes;i++)
	{
		brushes->nbrushes=i;
		int which_brush, npts;
		fscanf(fp, "brush %d: %d\n", &which_brush, &npts);
		for(j=0;j<npts;j++)
		{
			fscanf(fp, "%f, %f, %d\n", &x, &y, &cellid);
			add_to_current_brushPts(x, y);
		}
		convert_one_brush_to_atraj(brushes->nbrushes);
	}
	brushes->nbrushes=nbrushes;
}




/*
       We will use this routine to connect two specific points (close enough)
	   in the domain using different schemes determined by "type"
	   type: 0-- use the vector determined by the two points p1-->p2
			 1-- use the user specified direction
			 2-- use the underlying field
*/

void get_linesegs_anytwopts(double p1[2], int cell1, 
						double p2[2], int cell2,
						Trajectory *traj, int type, int MaxIters)
{
	double pre_p[2]={p1[0], p1[1]};
	double cur_p[2]={p2[0], p2[1]};
	int i, j;
	int cur_cell = cell1;
	QuadCell *face;
	icVector2 linedir, line_dir2;
	linedir.set((cur_p[0]-pre_p[0]),(cur_p[1]-pre_p[1]));
	normalize(linedir);
	tenline_dir_global = linedir;

	cur_cell=cell1;

	icVector2 t_major[4];

	for(i=0;i<MaxIters;i++)
	{
		if(cur_cell==cell2)
			break;

		if(cur_cell<0 || cur_cell>=quadmesh->nfaces)
			return;

		if(!is_in_cell(cur_cell, cur_p[0], cur_p[1]))
		{
			face = quadmesh->quadcells[cur_cell];

			if(type==0||type==1)
			{
				for(j=0; j<4; j++)
					t_major[j]=quadmesh->quad_verts[face->verts[j]]->major;

				/*replace them with the line segment direction*/
				for(j=0; j<4; j++)
					//quadmesh->quad_verts[face->verts[i]]->major=linedir;
					quadmesh->quad_verts[face->verts[j]]->major=tenline_dir_global;
			}

			int passvertornot = 0;
			double tp[2]={pre_p[0], pre_p[1]};
			get_next_cell_2(cur_cell, pre_p, cur_p, passvertornot, 0);
			
			if(traj->nlinesegs>=traj->curMaxNumLinesegs)
			{
				traj->extend_line_segments(5);
			}

			if(passvertornot>0)
			{
				/*we need to add one more line segment here*/
				traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
				traj->linesegs[traj->nlinesegs].gstart[0]=tp[0];
				traj->linesegs[traj->nlinesegs].gstart[1]=tp[1];
				traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
				traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
				line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
					traj->linesegs[traj->nlinesegs].gstart[0];
				line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
					traj->linesegs[traj->nlinesegs].gstart[1];
				traj->linesegs[traj->nlinesegs].length=length(line_dir2);
				traj->nlinesegs++;
				
				tp[0]=cur_p[0];
				tp[1]=cur_p[1];
				cur_p[0]=pre_p[0];
				cur_p[1]=pre_p[1];
				pre_p[0]=tp[0];
				pre_p[1]=tp[1];
			}

			/*we need to add one more line segment here*/
			traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
			traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
			traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
			traj->linesegs[traj->nlinesegs].gend[0]=cur_p[0];
			traj->linesegs[traj->nlinesegs].gend[1]=cur_p[1];
			line_dir2.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
				traj->linesegs[traj->nlinesegs].gstart[0];
			line_dir2.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
				traj->linesegs[traj->nlinesegs].gstart[1];
			traj->linesegs[traj->nlinesegs].length=length(line_dir2);
			traj->nlinesegs++;

			pre_p[0]=cur_p[0];
			pre_p[1]=cur_p[1];
			cur_p[0]=p2[0];
			cur_p[1]=p2[1];

			/*store back the original vectors*/
			if(type==0 || type==1)
			{
				for(j=0; j<4; j++)
					quadmesh->quad_verts[face->verts[j]]->major=t_major[j];
			}
		}
	}

	if(cur_cell<0 || cur_cell>=quadmesh->nfaces)
		return;

	//if(i>=MaxIters)
	//	return;


	/*add one more line segment*/
	if(traj->nlinesegs>=traj->curMaxNumLinesegs)
	{
		traj->extend_line_segments(5);
	}
	traj->linesegs[traj->nlinesegs].Triangle_ID=cur_cell;
	traj->linesegs[traj->nlinesegs].gstart[0]=pre_p[0];
	traj->linesegs[traj->nlinesegs].gstart[1]=pre_p[1];
	traj->linesegs[traj->nlinesegs].gend[0]=p2[0];
	traj->linesegs[traj->nlinesegs].gend[1]=p2[1];
	linedir.entry[0]=traj->linesegs[traj->nlinesegs].gend[0]-
		traj->linesegs[traj->nlinesegs].gstart[0];
	linedir.entry[1]=traj->linesegs[traj->nlinesegs].gend[1]-
		traj->linesegs[traj->nlinesegs].gstart[1];
	traj->linesegs[traj->nlinesegs].length=length(linedir);
	traj->nlinesegs++;
	
}





/*********************************************************************/
/*																	 */
/*                         Initialization                            */
/*********************************************************************/

void init_sketchnet()
{
	if(sketchnet == NULL)
		//delete streetnet;
		sketchnet=new StreetNet(20, 80);
	sketchnet->reset_streetnet();
	init_sketchline_intersectionlists();
}


/*this will be called after converting the sketch curves 
into trajectories*/
void init_sketchline_intersectionlists()
{
	int i;
	if(sketchlineintersectinfo != NULL)
	{
		for(i=0;i<prev_nsketchlines; i++)
			if(sketchlineintersectinfo[i]!=NULL)
			{
				delete sketchlineintersectinfo[i];
				sketchlineintersectinfo[i]=NULL;
			}
		delete [] sketchlineintersectinfo;
		sketchlineintersectinfo = NULL;
	}

	if(sketchlineintersectinfo == NULL)
	{
		sketchlineintersectinfo = new TensorLineIntersectionInfoList *[sketchlines->ntrajs];
		for(i=0; i<sketchlines->ntrajs; i++)
			sketchlineintersectinfo[i] = new TensorLineIntersectionInfoList();
		prev_nsketchlines=sketchlines->ntrajs;
	}
}


void init_sketchlineinfo_incells()
{
	int i, j;
	QuadCell *face;
	for(i=0; i<quadmesh->nfaces;i++)
	{
		/**/
		face=quadmesh->quadcells[i];

		if(face->sketchlines!=NULL)
		{
			delete face->sketchlines;
			face->sketchlines=NULL;
		}
	}
}
